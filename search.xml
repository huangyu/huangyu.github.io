<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OkHttp源码分析]]></title>
    <url>%2Farchives%2Fc92f2cb8.html</url>
    <content type="text"><![CDATA[OkHttp介绍https://github.com/square/okhttpAn HTTP &amp; HTTP/2 client for Android and Java applications.OkHttp是支持HTTP、HTTP2的网络请求库。这里解析的是OkHttp 3.11.0版本的代码。使用方式：创建client1OkHttpClient client = new OkHttpClient();创建网络请求123Request request = new Request.Builder() .url(ENDPOINT) .build();发送请求12345// 同步方式Response response = client.newCall(request).execute()// 异步方式client.newCall(request).enqueue(callback)OkHttpClient123public OkHttpClient() &#123; this(new Builder());&#125;OkHttpClient使用Builder模式创建，负责管理全局需要的配置。Request的创建Request的创建也使用了Builder模式，负责单个请求的配置信息。1234567Request(Builder builder) &#123; this.url = builder.url; this.method = builder.method; this.headers = builder.headers.build(); this.body = builder.body; this.tags = Util.immutableMap(builder.tags); &#125;发起请求client.newCall(request)负责构建一个RealCall，RealCall里存储了一个Request和OkHttpClient，以及请求的事件回调EventListener等信息。12@Override public Call newCall(Request request) &#123; return RealCall.newRealCall(this, request, false /* for web socket */);RealCall实现了OkHttp3.Call接口，实现了请求的发起、执行、取消、状态判断等。1234567891011121314151617181920public interface Call extends Cloneable &#123; Request request(); Response execute() throws IOException; void enqueue(Callback responseCallback); void cancel(); boolean isExecuted(); boolean isCanceled(); Call clone(); interface Factory &#123; Call newCall(Request request); &#125;&#125;Dispathcer无论同步和异步请求均使用到了Dispathcer，负责进行请求的管理，例如取消请求、返回请求和数量等处理。1234567891011121314// 最大请求数private int maxRequests = 64;// 同Host最大请求数private int maxRequestsPerHost = 5;// 异步请求处于准备的队列（超过上述请求限制则的异步请求会放入此队列）private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();// 异步请求正在执行的队列private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();// 同步请求队列private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();对于异步请求队列，Dispatcher会开启一个线程池进行处理。1234567public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false)); &#125; return executorService;&#125;同步请求execute()方法用于发送同步请求，等待请求响应返回一个Response。1234567891011121314151617181920@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); try &#123; // 核心代码下面两行利用Dispatcher执行 client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; &#125; catch (IOException e) &#123; eventListener.callFailed(this, e); throw e; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125;异步请求enqueue()则是发送异步请求，每个请求是一个AsyncCall，将请求加入队列，在Dispatcher的线程池进行处理。123456789@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125;AsyncCall持有一个Callback，在execute处理请求，回调给调用方。1234567891011121314151617181920212223@Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;)); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e); &#125; else &#123; eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125;getResponseWithInterceptorChain()无论同步还是异步请求，最终都由getResponseWithInterceptorChain方法返回响应Response。这里用到了责任链模式，通过一系列拦截器对请求进行加工处理。12345678910111213141516171819Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest);&#125;此处借用Piasy的图：在配置 OkHttpClient 时设置的 interceptors；负责失败重试以及重定向的 RetryAndFollowUpInterceptor；负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的 BridgeInterceptor；负责读取缓存直接返回、更新缓存的 CacheInterceptor；负责和服务器建立连接的 ConnectInterceptor；配置 OkHttpClient 时设置的 networkInterceptors；负责向服务器发送请求数据、从服务器读取响应数据的 CallServerInterceptor。至此OkHttp请求发送和响应解析完毕。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android属性动画]]></title>
    <url>%2Farchives%2Fc521d2cf.html</url>
    <content type="text"><![CDATA[Android动画分为几种：补间动画、属性动画，还有帧动画等。补间动画并没有真正去改变其属性，当View使用补间动画变换后点击是没有效果的，因为它的真实位置还在原来的地方。属性动画则是将View的属性进行改变从而实现动画效果。ValueAnimator属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。ValueAnimator内部使用一种时间循环的机制来计算值与值之间的动画过渡。1234567&lt;animator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot; android:valueFrom=&quot;1&quot; android:valueTo=&quot;0&quot; android:valueType=&quot;floatType&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot;/&gt;ObjectAnimatorObjectAnimator是ValueAnimator子类，动画所给的对象,他会调用对象对应属性的get/set方法吧属性的值设置给对象的属性，直接实现动画效果。123456789/** * 第一个参数：目前空间 * 第二个参数：该控件的属性值 * 第三个参数：属性的开始值 * 第四个参数：属性的结束值 */ObjectAnimator anim = ObjectAnimator.ofFloat(view, “alpha”, 0f, 1f);anim.setDuration(1000);anim.start();常用的属性动画参数的属性对应的set方法实现的效果alphasetAlpha改变透明度translationXsetTranslationX沿X轴平移translationYsetTranslationY沿Y轴平移scaleXsetScaleX沿X轴缩放scaleYsetScaleY沿Y轴缩放rotationXsetRotationX绕X轴旋转rotationYsetRotationY绕Y轴旋转rotationsetRotation绕Z轴旋转ViewPropertyAnimatorViewPropertyAnimator只能作用于View而不能作用于其他object。假如需要同时对多个属性执行动画时，ViewPropertyAnimator效率更高，代码更简洁、更易读。1view.animate().x(500f).y(500f).start();AnimationSet组合动画AnimationSet用于组合多个动画进行复杂的动画显示，可以设定动画的先后顺序。123456789AnimatorSet animatorSet = new AnimatorSet();ObjectAnimator objectAnimatorTranslate = ObjectAnimator.ofFloat(iv, &quot;translationX&quot;, 0f, 500f);ObjectAnimator objectAnimatorRotateX = ObjectAnimator.ofFloat(iv, &quot;rotationX&quot;, 0f, 360f);ObjectAnimator objectAnimatorRotateY = ObjectAnimator.ofFloat(iv, &quot;rotationY&quot;, 0f, 360f);animatorSet.setDuration(1000);animatorSet.play(objectAnimatorTranslate) .after(objectAnimatorRotateX) .after(objectAnimatorRotateY);animatorSet.start();AnimationListener动画执行的监听，用于监听动画回调实现自定义功能。onAnimationStart 动画开始onAnimationRepeat 重复动画onAnimationEnd 动画结束Interpolator插值器动画变换时如果想实现非线性效果，则可使用Interpolator插值器。所有的Interpolator都实现了Interpolator接口，这个接口定义了一个方法：float getInterpolation(float input)，此方法由系统调用，input代表动画的时间，在0和1之间，也就是开始和结束之间。系统内置有九种：AccelerateDecelerateInterpolator 在动画开始与介绍的地方速率改变比较慢，在中间的时候加速AccelerateInterpolator 在动画开始的地方速率改变比较慢，然后开始加速AnticipateInterpolator 开始的时候向后甩一点然后向前AnticipateOvershootInterpolator 开始的时候向后甩一点然后向前超过设定值一点然后返回BounceInterpolator 动画结束的时候弹起，类似小球落地CycleInterpolator 动画循环播放特定的次数回到原点，速率改变沿着正弦曲线DecelerateInterpolator 在动画开始的地方快然后慢LinearInterpolator 以线性常量速率改变OvershootInterpolator 向前超过设定值一点然后返回到原来位置另外，插值器也可以自定义。所有的Interpolator都实现了Interpolator接口，这个接口定义了一个方法：float getInterpolation(float input)，此方法由系统调用，input代表动画的时间，在0和1之间，也就是开始和结束之间。例如：LinearInterpolator：123public float getInterpolation(float input) &#123; return input; &#125;PropertyValuesHolderPropertyValuesHolder保存了动画过程中所需要操作的属性和对应的值。12345678// 将需要操作的多个属性和值封装起来，一起放到ObjectAnimator中，相当于set操作。PropertyValuesHolder rotateHolder = PropertyValuesHolder.ofFloat(&quot;Rotation&quot;, 0, 360, 0, -360,0);PropertyValuesHolder scaleXHolder = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;, 1, 2, 1,2,1);PropertyValuesHolder scaleYHolder = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;, 1, 2, 1,2,1);ObjectAnimator objectAnim = ObjectAnimator.ofPropertyValuesHolder(ivHolderTarget,rotateHolder, scaleXHolder, scaleYHolder);objectAnim.setDuration(2000);objectAnim.setInterpolator(new LinearInterpolator());objectAnim.start();KeyFrameKeyframe用来保存一对时间/变量的动画值。123456789101112// fraction：代表一个动画的时间值，范围为0-1，动画从0开始，到1结束。// value：就是在对应时间点所要设置的变量值。Keyframe.ofFloat(float fraction, float value)Keyframe scaleFrame1 = Keyframe.ofFloat(0f, 1.0f);Keyframe scaleFrame2 = Keyframe.ofFloat(0.5f, 2.0f);Keyframe scaleFrame3 = Keyframe.ofFloat(1.0f, 1.0f);PropertyValuesHolder scaleX = PropertyValuesHolder.ofKeyframe(&quot;scaleX&quot;, scaleFrame1, scaleFrame2, scaleFrame3);PropertyValuesHolder scaleY = PropertyValuesHolder.ofKeyframe(&quot;scaleY&quot;, scaleFrame1, scaleFrame2, scaleFrame3);ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(target, scaleX, scaleY);animator.setDuration(2000);animator.start();TypeEvaluatorTypeEvaluator可用于实现自定义计算动画的变化过程。1234567891011// 实现抛物线动画valueAnimator.setEvaluator(new TypeEvaluator() &#123; @Override public PointF evaluate(float fraction, PointF startValue, PointF endValue) &#123; /** x方向 10px/s ，则 y方向 0.5 * 100 * t **/ PointF point = new PointF(); point.x = 10 * fraction; point.y = 0.5f * 10 * fraction * fraction; return point; &#125;&#125;);其他同个动画可以多种方式实现，例如将View移动到(100f, 100f)坐标：1、多个ObjectAnimator 组合12345ObjectAnimator animX = ObjectAnimator.ofFloat(view, &quot;x&quot;, 100f);ObjectAnimator animY = ObjectAnimator.ofFloat(view, &quot;y&quot;, 100f);AnimatorSet animSet = new AnimatorSet();animSet.playTogether(animX, animY);animSet.start();2、使用ViewPropertyAnimator123PropertyValuesHolder xHolder = PropertyValuesHolder.ofFloat(&quot;x&quot;, 100f);PropertyValuesHolder yHolder = PropertyValuesHolder.ofFloat(&quot;y&quot;, 100f);ObjectAnimator.ofPropertyValuesHolder(view, xHolder, yHolder).start();3、使用一个ObjectAnimator + PropertyValuesHolder1view.animate().x(100f).y(100f).start();]]></content>
      <categories>
        <category>属性动画</category>
      </categories>
      <tags>
        <tag>属性动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit源码分析]]></title>
    <url>%2Farchives%2F41113d0.html</url>
    <content type="text"><![CDATA[Retrofit介绍https://github.com/square/retrofitType-safe HTTP client for Android and Java。根据官方介绍，Retrofit是可用于Android和Java的类型安全的HTTP客户端库。这里解析的是Retrofit 2.4.0版本的代码。使用方式：创建一个interface服务接口包含请求接口合集，使用注解进行配置：1234public interface GitHubService &#123; @GET(&quot;users/&#123;user&#125;/repos&quot;) Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);&#125;使用时获取Retrofit和创建interface实例：1234Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;https://api.github.com/&quot;) .build();GitHubService service = retrofit.create(GitHubService.class);􏰄调用interface具体方法创建：1Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);使用Call.execute()发送同步或者Call.enqueue()发送异步请求：1repos.enqueue(callback);Retrofit的创建和很多其他库一样，Retrofit的创建使用了Builder模式，在此不做赘述。Retrofit.create()12345678910111213141516171819202122232425262728public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; // 将interface声明的接口方法提前解析并存在serviceMethodCache里 eagerlyValidateMethods(service); &#125; // 使用动态代理模式创建interface接口服务实例 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; // 将方法解析并存在serviceMethodCache里 return loadServiceMethod(method).invoke(args != null ? args : emptyArgs); &#125; &#125;); &#125;ServiceMethod和HttpServiceMethodRetrofit里有个serviceMethodCache是存着ServiceMethod的ConcurrentHashMap，ServiceMethod用于解析interface服务里的方法注解， 把对接口方法的调用转为一次HTTP调用。新版本中，ServiecMethod为抽象类，其实现类为HttpServiceMethod。核心方法是parseAnnotations和invoke方法。HttpServiceMethod.parseAnnotations()12345678910111213141516171819202122static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt;parseAnnotations( Retrofit retrofit, Method method, RequestFactory requestFactory) &#123; // 创建CallAdapter，在Retrofit类内部，遍历一个CallAdapter.Factory列表，让工厂们提供 CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method); Type responseType = callAdapter.responseType(); if (responseType == Response.class || responseType == okhttp3.Response.class) &#123; throw methodError(method, &quot;&apos;&quot; + Utils.getRawType(responseType).getName() + &quot;&apos; is not a valid response body type. Did you mean ResponseBody?&quot;); &#125; if (requestFactory.httpMethod.equals(&quot;HEAD&quot;) &amp;&amp; !Void.class.equals(responseType)) &#123; throw methodError(method, &quot;HEAD method must use Void as response type.&quot;); &#125; // 创建ResponseConverter，在Retrofit类内部，遍历一个Converter.Factory列表，让工厂们提供 Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType); // 返回一个HttpServiceMethod okhttp3.Call.Factory callFactory = retrofit.callFactory; return new HttpServiceMethod&lt;&gt;(requestFactory, callFactory, callAdapter, responseConverter); &#125;HttpServiceMethod的构造函数几个重要参数作用：RequestFactory：构造HTTP请求，Retrofit基于OKHttp进行封装，最终HTTP请求被抽象为了okhttp3.Call类。okhttp3.Call.Factory：OkHttp创建请求的工厂类。CallAdapter：用于将返回Body转为具体的类型，即将retrofit2.Call转为T。Converter：Converter&lt;ResponseBody, T&gt;类型，负责把服务器返回的数据（JSON、XML、二进制或者其他格式，由ResponseBody封装）转化为T类型的对象。HttpServiceMethod.invoke()1234@Override ReturnT invoke(Object[] args) &#123; return callAdapter.adapt( new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter));&#125;invoke在retrofit的create方法里动态代理中调用，在DefaultCallAdapterFactory里通过callAdapter.adapt将接口转为OkHttpCall。综上，Retrofit.create()使用动态代理创建了interface实例，通过parseAnnotations将注解定义好的接口方法解析为ServiceMethod，ServiceMethod已经包含了HTTP请求和响应所需的CallAdapter和Converter等，并存到一个serviceMethodCache里面，当使用interface接口方法时，即调用动态代理类的invoke方法，将请求转为OkHttpCall。Call.execute()Retrofit的同步请求方法，即OkHttpCall.execute()。123456789101112131415161718192021222324@Override public Response&lt;T&gt; execute() throws IOException &#123; okhttp3.Call call; synchronized (this) &#123; ... call = rawCall; if (call == null) &#123; try &#123; // 通过callFactory创建okhttp3.Call call = rawCall = createRawCall(); &#125; catch (IOException | RuntimeException | Error e) &#123; throwIfFatal(e); // Do not assign a fatal error to creationFailure. creationFailure = e; throw e; &#125; &#125; &#125; ... // okhttp3.Call使用OkHttp的execute方法，并解析响应 return parseResponse(call.execute()); &#125;1234567891011121314151617Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body(); ... ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody); try &#123; // 核心就是通过responseConverter将响应体进行转换，上面写到了Converter作用就是将ResponseBody转为T T body = responseConverter.convert(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; // If the underlying source threw an exception, propagate that rather than indicating it was // a runtime exception. catchingBody.throwIfCaught(); throw e; &#125; &#125;即最终通过底层的OkHttp将请求转为T类型。Call.enqueue()Retrofit的异步请求方法，即OkHttpCall.enqueue()，通过OkHttp的enqueue执行请求并解析响应，和上述execute基本过程是一致的，只不过是异步处理。至此Retorfit请求发送和响应解析完毕。OkHttp请求详见OkHttp源码分析。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie、Authorization]]></title>
    <url>%2Farchives%2Fa4a89e45.html</url>
    <content type="text"><![CDATA[Cookie⼯作机制:服务器需要客户端保存的内容，放在 Set-Cookie headers 里返回，客户端会自动保存。客户端保存的 Cookies，会在之后的所有请求里都携带进 Cookie header ⾥发回给服务器。客户端保存的 Cookie 是按照服务器域名来分类的。客户端保存的 Cookie 在超时后会被删除、没有设置超时间的 Cookie (称作 Session Cookie)在浏览器关闭后就会⾃动删除；另外，服务器也可以主动删除还未过期的客户端 Cookies。使用场景：会话管理：登录状态、购物⻋个性化：⽤用户偏好、主题Tracking：分析用户行为Authorization两种主流⽅式: Basic 和 BearerBasic:格式：Authorization: Basic username:password(Base64ed)Bearer:格式：Authorization: Bearerbearer token 的获取⽅方式:通过 OAuth2 的授权流程OAuth2流程以下摘取自阮一峰博客：A: 用户打开客户端以后，客户端要求用户给予授权。B: 用户同意给予客户端授权。C: 客户端使用上一步获得的授权，向认证服务器申请令牌。D: 认证服务器对客户端进行认证以后，确认无误，同意发放令牌。E: 客户端使用令牌，向资源服务器申请获取资源。F: 资源服务器确认令牌无误，同意向客户端开放资源。API接口的token有的 App 会在 Api 的设计中，将登录和授权设计成类似 OAuth2 的过程，但简化掉 Authorization code 概念。即：登录接口请求成功时，会返回 access token，然后客户端在之 后的请求中，就可以使用这个 access token 来当做 bearer token 进⾏用户操作了了。刷新Tokenaccess token 有失效时间，在它失效后，调⽤用 refresh token 接口，传⼊入 refresh_token 来获取新的 access token。⽬的：安全。当 access token 失窃，由于它有失效时间，因此坏⼈只有较短的时间来「做坏 事」;同时，由于(在标准的 OAuth2 流程中)refresh token 永远只存在与第三方服务的服务器中，因此 refresh token ⼏乎没有失窃的⻛险。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Authorization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP三次握手与四次挥手]]></title>
    <url>%2Farchives%2F14e70aec.html</url>
    <content type="text"><![CDATA[TCP，提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，TCP报文建立连接和释放连接几个重要标志：序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号。确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号。确认ACK：占1个比特位，仅当ACK=1，确认号字段才有效。ACK=0，确认号无效。同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使用SYN=1，ACK=1。终止FIN：希望断开连接。TCP连接的建立（三次握手）Q: 为何需要三次握手？A: 如果客户端迟迟没有收到服务器返回确认报文，这时会放弃连接，重新启动一条连接请求，而服务器不知道客户端没有收到，所以他会收到两个连接，浪费连接开销。如果每次都是这样，就会浪费多个连接开销。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。TCP连接的断开（四次挥手）Q: 为何需要四次挥手？A：关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。Q: 为什么客户端最后一次挥手需要等待2MSL时间？A: MSL即Maximum Segment Lifetime，就是最大报文生存时间，是任何报文在网络上的存在的最长时间，超过这个时间报文将被丢弃。第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码、加密、Hash、序列化]]></title>
    <url>%2Farchives%2F386e4652.html</url>
    <content type="text"><![CDATA[密码学一种优秀的对称加密算法的标准是，让破解者找不到比穷举法(暴⼒破解法)更有效的破解手段，并且穷举法的破解时间⾜够长(例如数千年)。对称加密算法：DES(56 位密钥，密钥太短⽽逐渐被弃用)、AES(128 位、192 位、256 位密钥，现在最流⾏)优点：速度快，方式简单。缺点：密钥泄露:不能在不安全网络上传输密钥，⼀旦密钥泄露则加密通信失败。破解方法：设法找到⼀个密钥，这个密钥可以将这些原文-密文对中的原文加密为密文，以及将密文解密为 原文的组合，即为成功破解。非对称加密使用非对称加密通信，可以在不可信⽹络上将双⽅的公钥传给对方，然后在发消息前分别对消息使用对方的公钥来加密和使⽤自己的私钥来签名，做到不可信网络上的可靠密钥传播及加密通信。算法：RSA、DSA。优点：可以在不安全网络上传输密钥。缺点：计算复杂，因此性能相比对称加密差很多。破解方法：穷举法，只是和对称加密破解的区别在于，对称加密破解是不断尝试⼰己的新密 钥是否可以将⾃己拿到的原⽂-密文对进行加密和解密，⽽而⾮对称加密时不断尝试⾃己的新私钥 是否和公钥互相可解。数字签名加密 + 签名可以防止数据伪造和中间人攻击。混合加密加密过程：解密过程：Base64将原数据每 6 位对应成 Base 64 索引表中的⼀个字符编排成⼀个字符串。（二进制数据转为字符串）应用：Base64对图⽚进行编码，使⽤文本形式来传输图片。Base64 并不是加密，另外，Base64 会导致数据增⼤ 1/3，降低⽹网络性能，增⼤用户流量开销。Hash把任意数据转换成指定⼤小范围(通常很小，例如 256 字节以内)的数据。作用：相当于从数据中提出摘要信息，因此最主要⽤用途是数字指纹。用途：数据完整性验证，快速检索（HashMap）、隐私保护（密码hash存储）算法： MD5、SHA1。序列化把数据对象(⼀般是内存中的，例例如 JVM 中的对象)转换成字节序列的过程。作用：让内存中的对象可以被储存和传输。字符集]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>密码学、Hash、编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP知识]]></title>
    <url>%2Farchives%2Fd27d50fd.html</url>
    <content type="text"><![CDATA[HTTP定义Hypertext Transfer Protocol，超⽂文本传输协议，和 HTML (Hypertext Markup Language 超⽂文本标 记语⾔言) ⼀一起诞⽣生，⽤用于在⽹网络上请求和传输 HTML 内容。超⽂文本，即「扩展型⽂文本」，指的是 HTML 中可以有链向别的⽂文本的链接(hyperlink)。URL格式URL格式：协议类型://服务器器地址[:端⼝号]路径http://hencoder.com/users?gender=male报文格式请求报文：响应报文：HTTP方法GET用于获取资源对服务器器数据不进行修改不发送Body12GET /users/1 HTTP/1.1Host: api.github.com对应 Retrofit 的代码:12@GET(&quot;/users/&#123;id&#125;&quot;)Call&lt;User&gt; getUser(@Path(&quot;id&quot;) String id, @Query(&quot;gender&quot;) String gender);POST用于增加或修改资源发送给服务器器的内容写在Body⾥面12345POST /users HTTP/1.1Host: api.github.comContent-Type: application/x-www-form-urlencodedContent-Length: 13name=rengwuxian&amp;gender=male对应 Retrofit 的代码:1234@FormUrlEncoded@POST(&quot;/users&quot;)Call&lt;User&gt; addUser(@Field(&quot;name&quot;) String name, @Field(&quot;gender&quot;) Stringgender);PUT用于修改资源发送给服务器器的内容写在Body里面12345PUT /users/1 HTTP/1.1Host: api.github.comContent-Type: application/x-www-form-urlencodedContent-Length: 13gender=female对应 Retrofit 的代码：1234@FormUrlEncoded@PUT(&quot;/users/&#123;id&#125;&quot;)Call&lt;User&gt; updateGender(@Path(&quot;id&quot;) String id, @Field(&quot;gender&quot;) Stringgender);DELETE用于删除资源不发送Body12DELETE /users/1 HTTP/1.1Host: api.github.com对应 Retrofit 的代码：12@DELETE(&quot;/users/&#123;id&#125;&quot;)Call&lt;User&gt; getUser(@Path(&quot;id&quot;) String id, @Query(&quot;gender&quot;) String gender);HEAD和 GET 使⽤用⽅方法完全相同和 GET 唯⼀一区别在于，返回的响应中没有 Body其中GET、PUT、DELETE、HEAD是幂等的。HTTP响应码常用响应码：100：继续，用于多段HTTP请求。101：切换协议。例如由HTTP1.1变为2.0200：请求成功。301：资源被永久移动，浏览器会自动定向到新URI。302：资源被临时移动，客户端应继续使用原有URI。400：客户端语法错误，服务器无法解析。401：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。403：服务器理解请求客户端的请求，但是拒绝执行此请求。404：服务器无法根据客户端的请求找到资源。500：服务器内部错误，无法完成请求。HeaderContent-Type内容类型，主要有四类:text/html请求 Web ⻚页⾯面是返回响应的类型，Body 中返回 html ⽂文本。格式如下:12345678HTTP/1.1 200 OKContent-Type: text/html; charset=utf-8Content-Length: 853&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;......x-www-form-urlencodedWeb ⻚页⾯面纯⽂文本表单的提交⽅方式。格式如下：12345POST /users HTTP/1.1Host: api.github.comContent-Type: application/x-www-form-urlencodedContent-Length: 27name=rengwuxian&amp;gender=male对应 Retrofit 的代码:1234@FormUrlEncoded@POST(&quot;/users&quot;)Call&lt;User&gt; addUser(@Field(&quot;name&quot;) String name, @Field(&quot;gender&quot;) Stringgender);multitype/form-dataWeb ⻚页⾯面含有⼆二进制⽂文件时的提交⽅方式。格式如下:123456789101112POST /users HTTP/1.1Host: hencoder.comContent-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gWContent-Length: 2382------WebKitFormBoundary7MA4YWxkTrZu0gWContent-Disposition: form-data; name=&quot;name&quot;rengwuxian------WebKitFormBoundary7MA4YWxkTrZu0gWContent-Disposition: form-data; name=&quot;avatar&quot;; filename=&quot;avatar.jpg&quot;Content-Type: image/jpegJFIFHHvOwX9jximQrWa......对应 Retrofit 的代码:12345678910@Multipart@POST(&quot;/users&quot;)Call&lt;User&gt; addUser(@Part(&quot;name&quot;) RequestBody name, @Part(&quot;avatar&quot;)RequestBody avatar);...RequestBody namePart = RequestBody.create(MediaType.parse(&quot;text/plain&quot;),nameStr);RequestBody avatarPart = RequestBody.create(MediaType.parse(&quot;image/jpeg&quot;),avatarFile);api.addUser(namePart, avatarPart);application/json , image/jpeg , application/zip …单项内容(⽂文本或⾮非⽂文本都可以)，⽤用于 Web Api 的响应或者 POST / PUT 的请求 请求中提交 JSON。JSON方式请求中提交JSON:12345POST /users HTTP/1.1Host: hencoder.comContent-Type: application/json; charset=utf-8Content-Length: 38&#123;&quot;name&quot;:&quot;rengwuxian&quot;,&quot;gender&quot;:&quot;male&quot;&#125;对应 Retrofit 的代码:1234@POST(&quot;/users&quot;)Call&lt;User&gt; addUser(@Body(&quot;user&quot;) User user);...// 需要使⽤用 JSON 相关的 Converter api.addUser(user);响应返回JSON：123456HTTP/1.1 200 OKcontent-type: application/json; charset=utf-8content-length: 234[&#123;&quot;login&quot;:&quot;mojombo&quot;,&quot;id&quot;:1,&quot;node_id&quot;:&quot;MDQ6VXNlcjE=&quot;,&quot;avatar_url&quot;:&quot;https://avatars0.githubusercontent.com/u/1?v=4&quot;,&quot;gravat......二进制方式请求中提交二进制内容：12345POST /user/1/avatar HTTP/1.1Host: hencoder.comContent-Type: image/jpegContent-Length: 1575JFIFHH9......对应 Retrofit 的代码:123456@POST(&quot;users/&#123;id&#125;/avatar&quot;)Call&lt;User&gt; updateAvatar(@Path(&quot;id&quot;) String id, @Body RequestBody avatar);...RequestBody avatarBody = RequestBody.create(MediaType.parse(&quot;image/jpeg&quot;),avatarFile);api.updateAvatar(id, avatarBody)响应中返回二进制内容：1234HTTP/1.1 200 OKcontent-type: image/jpegcontent-length: 1575JFIFHH9......Content-Length指定 Body 的⻓长度(字节)。Transfer: chunked (分块传输编码 Chunked Transfer Encoding)⽤于当响应发起时，内容⻓长度还没能确定的情况下。和 Content-Length 不不同时使⽤用。⽤用途是尽早给 出响应，减少⽤用户等待。格式:12345678910HTTP/1.1 200 OKContent-Type: text/htmlTransfer-Encoding: chunked4Chun9ked Trans12fer Encoding0Location指定重定向的⽬目标 URLUser-Agent用户代理，即是谁实际发送请求、接受响应的，例如⼿机浏览器、某款手机App。Range / Accept-Range按范围取数据。Accept-Range: bytes 响应报⽂文中出现，表示服务器器⽀支持按字节来取范围数据 Range: bytes=-请求报⽂文中出现，表示要取哪段数据 Content-Range:-/total 响应报⽂文中出现，表示发送的是哪段数据作⽤：断点续传、多线程下载。charset编码，例如utf-8。HTTP缓存ETagETag是服务器生成并返回的随机令牌，通常是文件内容的哈希值或某个其他指纹。验证令牌可实现高效的资源更新检查：资源未发生变化时不会传送任何数据，服务器将返回“304 Not Modified”响应。在下一次请求中，If-None-Match的值为上次的ETag的值。服务器根据If-None-Match的值（即内容摘要）判断缓存的资源是否有效。Cache-Controlno-cache：表示必须先与服务器确认返回的响应是否发生了变化，然后才能使用该响应来满足后续对同一网址的请求。no-store：直接禁止浏览器以及所有中间缓存存储任何版本的返回响应。public：是指资源应该被缓存，并且中间经过的代理服务器（假如有的话）也应该缓存这个资源。private：是指资源应该被缓存，但是只能被客户端的浏览器缓存。max-age：指令指定从请求的时间开始，允许获取的响应被重用的最长时间（单位：秒）Expires：表示在某个时间点后过期。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HenCoder</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin设计模式]]></title>
    <url>%2Farchives%2F5ff9cb15.html</url>
    <content type="text"><![CDATA[kotlin设计模式简单工厂定义一个工厂类，它可以根据参数的不同返回不同类的实例。SimpleFactory.kt工厂方法工厂方法把创建对象的过程抽象为接口，由工厂的子类决定对象的创建。FactoryMethod.kt抽象工厂工厂方法针对一种产品，而抽象工厂是针对一系列产品，为每种产品定义一个工厂方法，工厂子类负责创建该系列的多种产品。AbstractFactory.kt单例单例模式在Kotlin下直接使用object就行了。Singleton.kt建造者建造者模式是为了构建复杂对象的，一般情况下，Kotlin中使用标准的apply函数就可以。Builder.kt原型原型模式是以一个对象为原型，创建出一个新的对象，在Kotlin下很容易实现，用data class的copy就可以。Prototype.kt适配器适配器模式是把一个不兼容的接口转化为另一个类可以使用的接口。Adapter.kt桥接桥接模式可以分离某个类存在两个独立变化的纬度，把多层继承结构改为两个独立的继承结构，在两个抽象层中有一个抽象关联。Bridge.kt组合组合模式是对树形结构的处理，让调用者忽视单个对象和组合结构的差异。Composite.kt装饰装饰模式可以给一个对象添加额外的行为，在Kotlin下可以用扩展函数实现。Decorator.kt外观外观模式是为一个复杂的子系统提供一个简化的统一接口。Facade.kt享元享元模式以共享的方式高效地支持大量细粒度对象的重用，享元对象能做到共享的关键是区分了可共享内部状态和不可共享外部状态。FlyWeight.kt代理代理模式是使用一个代理对象来访问目标对象的行为。Proxy.kt责任链职责链模式通过建立一条链来组织请求的处理者，请求将沿着链进行传递。ChainReponsibility.kt命令命令模式是将请求封装为命令对象，解耦请求发送者与接收者，对请求排队或者记录请求日志，以及支持可撤销的操作。Command.kt解释器模式解释器模式是定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。Interpreter.kt迭代器迭代器模式提供一种不暴露底层实现情况下的遍历聚合对象中的元素的一种方式。Iterator.kt中介者中介者模式用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。Mediator.kt备忘录备忘录模式是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。Memento.kt观察者观察者模式是一个对象状态发生变化后，可以立即通知已订阅的另一个对象。Observer.kt状态模式状态模式将一个对象在不同状态下的不同行为封装在一个个状态类中，通过设置不同的状态可以让对象拥有不同的行为。State.kt策略模式策略模式用于算法的自由切换和扩展，分离算法的定义与实现，在 Kotlin 中可以使用高阶函数作为算法的抽象。Strategy.kt模版方法模板方法模式提供了一个模板方法来定义算法框架，而某些具体步骤的实现可以在其子类中完成，Kotlin 中使用高阶函数可以避免继承的方式。Template.kt访问者访问者模式提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。Visitor.kt]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-flow分支策略]]></title>
    <url>%2Farchives%2Feeda3694.html</url>
    <content type="text"><![CDATA[git-flow分支管理策略是非常流行的，实际项目的版本管理中可以借鉴其思想。https://nvie.com/posts/a-successful-git-branching-model/git-flow将分支分为以下几种类型：类型来源去向说明master主分支releasedevelopdevelop和master预发布分支developrelease和master开发分支featuredevelopdevelop功能分支hotfixmasterdevelop和master紧急修复分支 master主分支，永远是可用的、稳定的、可直接发布的版本；不能直接在该分支上开发；合并release稳定版本后打Tag确定版本。release预发布分支，在develop分支上创建，用于发布测试版本；修改好bug并确定稳定之后合并到develop和master分支，然后发布master分支；上线后可删除。创建并切换到release分支：1$ git checkout -b release-1.2 develop修复bug完毕提交：1$ git commit -a -m &quot;release 1.2&quot;release合并到master分支：12$ git checkout master$ git merge --no-ff release-1.2master分支打tag：1$ git tag -a 1.2删除release分支：1$ git branch -d release-1.2develop开发主分支，代码永远是最新；所有新功能以这个分支来创建自己的feature分支，该分支只做合并操作，不能直接在该分支上开发。feature功能分支，在develop上创建分支，以自己开发功能模块命名；功能测试正常后合并到develop分支，然后可删除。创建并切换到feature分支：1$ git checkout -b myfeature developfeature合并到develop分支：12$ git checkout develop$ git merge --no-ff myfeature开发完毕删除分支并推送：12$ git branch -d myfeature$ git push origin develophotfix紧急修复分支，项目上线之后可以会遇到Bug需要紧急修复，从master分支上创建；修复完成后合并到develop和master分支，然后可进行删除。创建并切换到hotfix分支：1$ git checkout -b hotfix-1.2.1 master修复完毕提交：1$ git commit -a -m &quot;hotfiex 1.2.1&quot;hotfix合并到master分支：12$ git checkout master$ git merge --no-ff hotfix-1.2.1master分支打tag：1$ git tag -a 1.2.1删除hotfix分支：1$ git branch -d hotfix-1.2.1除了master和develop分支是一直持续以外，其余分支工作完毕后可进行删除。分支命名规范分支命名规范建议如下：origin/类型/版本/描述例如：origin/masterorigin/release/1.0.0origin/release/1.0.1-bugfixorigin/developorigin/feature/1.0.1/AAAorigin/feature/1.0.1/BBBorigin/hotfix/1.0.0]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Picasso源码分析]]></title>
    <url>%2Farchives%2F38a31505.html</url>
    <content type="text"><![CDATA[Picasso介绍https://github.com/square/picassoPicasso是Android开发中常用的几大图片加载库之一，除此之外常用的还有UIL、Glide、Fresco等。目前UIL作者已经不再维护，Glide源码比较复杂，Fresco涉及c语言层面。相比之下Picasso写得比较简洁、规范，更好入手分析。通过分析Picasso源码来对Android的图片加载有更深入的理解。目前最新版本为2.71828（奇葩的版本号），本文基于此分析。最新的使用方式为：1PicassoProvider.get().load(&quot;url&quot;).into(imageview)下面就根据这个调用流程来分析其源码。图示Picasso的get方法此前Picasso包括Glide的调用方式都需要通过with(context)方法来传入context，最新版本通过一个get方法即可实现。项目中单独提供一个picasso-provider库工程实现此方法。123456789101112131415161718192021public final class PicassoProvider &#123; @SuppressLint(&quot;StaticFieldLeak&quot;) private static volatile Picasso instance; @Initializer public static Picasso get() &#123; if (instance == null) &#123; synchronized (PicassoProvider.class) &#123; if (instance == null) &#123; Context autoContext = PicassoContentProvider.context; if (autoContext == null) &#123; throw new NullPointerException(&quot;context == null&quot;); &#125; instance = new Picasso.Builder(autoContext).build(); &#125; &#125; &#125; return instance; &#125; ...&#125;此处使用双重校验锁来实现Picasso类单例。context的获取通过PicassoContentProvider类实现：12345678910public final class PicassoContentProvider extends ContentProvider &#123; @SuppressLint(&quot;StaticFieldLeak&quot;) @Nullable static Context context; @Override public boolean onCreate() &#123; context = getContext(); return true; &#125; ...&#125;此类在AndroidManifest中注册，因此在App启动的时候，系统就会自动回调PicassoContentProvider 的onCreate方法，因此也就自动获取到了Context。Picasso的创建Picasso通过Builder模式创建实例，通过以下这行代码获取实例。1instance = new Picasso.Builder(autoContext).build();Builder类构造函数：1234567891011121314151617181920Builder(Picasso picasso) &#123; context = picasso.context; // OkHttp的Call工厂，使用OkHttp处理网络请求 callFactory = picasso.callFactory; // 请求分发服务 service = picasso.dispatcher.service; // 缓存处理类 cache = picasso.cache; // 回调监听 listener = picasso.listener; // 变换器，List&lt;RequestTransformers&gt; requestTransformers.addAll(picasso.requestTransformers); // 计算请求处理器数量，List&lt;RequestHandler&gt;后续分析 int numRequestHandlers = picasso.requestHandlers.size(); requestHandlers.addAll(picasso.requestHandlers.subList(2, numRequestHandlers - 6)); defaultBitmapConfig = picasso.defaultBitmapConfig; indicatorsEnabled = picasso.indicatorsEnabled; loggingEnabled = picasso.loggingEnabled;&#125;build方法：1234567891011121314151617181920212223242526272829public Picasso build() &#123; Context context = this.context; // 配置OkHttp3 Cache和Factory okhttp3.Cache unsharedCache = null; if (callFactory == null) &#123; File cacheDir = createDefaultCacheDir(context); long maxSize = calculateDiskCacheSize(cacheDir); unsharedCache = new okhttp3.Cache(cacheDir, maxSize); callFactory = new OkHttpClient.Builder() .cache(unsharedCache) .build(); &#125; // 配置Picasso的Cache，使用LRU最近最少使用方式缓存 if (cache == null) &#123; cache = new PlatformLruCache(Utils.calculateMemoryCacheSize(context)); &#125; // 默认使用PicassoExecutorService线程池，用于后续Bitmap的获取 if (service == null) &#123; service = new PicassoExecutorService(); &#125; // 统计信息类，统计缓存命中，图片下载数等数据 Stats stats = new Stats(cache); // 请求分发，HANDLER在主线程处理事件，用于将获取到的Bitmap显示 Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, cache, stats); // 返回Picasso实例 return new Picasso(context, dispatcher, callFactory, unsharedCache, cache, listener, requestTransformers, requestHandlers, stats, defaultBitmapConfig, indicatorsEnabled, loggingEnabled);&#125;Picasso构造函数：1234567891011121314151617181920212223242526272829303132333435363738394041Picasso(...) &#123; ... // Picasso内置一个List&lt;RequestTransformer&gt;用于处理请求变换 this.requestTransformers = Collections.unmodifiableList(new ArrayList&lt;&gt;( ... // Picasso 默认包含8个内置 RequestHandler 分别用来处理8种不同类型的请求 int builtInHandlers = 8; ... // 可添加自定义的RequestHandler List&lt;RequestHandler&gt; allRequestHandlers = new ArrayList&lt;&gt;(builtInHandlers + extraCount); // ResourceRequestHandler，用于处理.xml资源文件 allRequestHandlers.add(ResourceDrawableRequestHandler.create(context)); // ResourceRequestHandler，用于处理Res资源文件 allRequestHandlers.add(new ResourceRequestHandler(context)); allRequestHandlers.addAll(extraRequestHandlers); // ContactsPhotoRequestHandler，用于处理手机联系人图片 allRequestHandlers.add(new ContactsPhotoRequestHandler(context)); // MediaStoreRequestHandler，用于处理content://media/开头的URI allRequestHandlers.add(new MediaStoreRequestHandler(context)); // ContentStreamRequestHandler，用于处理scheme为content的URI allRequestHandlers.add(new ContentStreamRequestHandler(context)); // AssetRequestHandler，用于处理file:///android_asset/开头的URI allRequestHandlers.add(new AssetRequestHandler(context)); // FileRequestHandler，用于处理scheme为file的URI allRequestHandlers.add(new FileRequestHandler(context)); // NetworkRequestHandler，用于处理http或https图片url allRequestHandlers.add(new NetworkRequestHandler(callFactory, stats)); // 返回一个不能进行修改操作的List实例，防止requestHandlers被修改 requestHandlers = Collections.unmodifiableList(allRequestHandlers); ... &#125;Picasso创建分析完毕。Picasso的load方法load方法对应不同的重载方法：包括int、String、Object、Uri等，以Uri为例：123public RequestCreator load(@Nullable Uri uri) &#123; return new RequestCreator(this, uri, 0);&#125;最终创建并返回一个RequestCreator实例。1234567RequestCreator(Picasso picasso, @Nullable Uri uri, int resourceId) &#123; ... // 持有Picasso实例 this.picasso = picasso; // 通过Builder创建Request this.data = new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);&#125;RequestCreator核心就是创建Request.Builder，即data实例。RequestCreator创建完成后，内部还包含placeholder、error、fit等方法，可继续链式调用，这里主要分析主流程，不详细赘述。RequestCreator的into方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void into(@NonNull ImageView target, @Nullable Callback callback) &#123; ... // data即前面的Request.Builder实例 // 如果data中没有图片(例如传入的path为null) // 直接对该target取消请求，并设置占位图如果有设置placeholder if (!data.hasImage()) &#123; picasso.cancelRequest(target); if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; return; &#125; ... // 创建请求 Request request = createRequest(started); // 如果当前的memoryPolicy允许从缓存中读取图片 // 从Cache中获取 requestKey 对应的Bitmap，如果该Bitmap存在 // 则取消当前请求，直接为target设置该Bitmap if (shouldReadFromMemoryCache(request.memoryPolicy)) &#123; Bitmap bitmap = picasso.quickMemoryCacheCheck(request.key); if (bitmap != null) &#123; picasso.cancelRequest(target); RequestHandler.Result result = new RequestHandler.Result(bitmap, MEMORY); setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled); if (picasso.loggingEnabled) &#123; log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), &quot;from &quot; + MEMORY); &#125; if (callback != null) &#123; callback.onSuccess(); &#125; return; &#125; &#125; // 前面缓存中没有查找到图片，从这里开始请求 // 先设置 placeholder 如果有配置的话 if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; // 创建ImageViewAction，主要将获取的Bitmap加载到ImageView中 Target&lt;ImageView&gt; wrapper = new Target&lt;&gt;(target, errorResId, errorDrawable, noFade); Action action = new ImageViewAction(picasso, wrapper, request, callback); // 加入异步请求队列处理 picasso.enqueueAndSubmit(action);&#125;createRequest创建Request实例。12345678910111213141516171819202122232425262728private Request createRequest(long started) &#123; int id = nextId.getAndIncrement(); // 创建Request Request request = data.build(); request.id = id; request.started = started; boolean loggingEnabled = picasso.loggingEnabled; if (loggingEnabled) &#123; log(OWNER_MAIN, VERB_CREATED, request.plainId(), request.toString()); &#125; // 如果有RequestTransformer，则逐一处理 Request transformed = picasso.transformRequest(request); if (transformed != request) &#123; // If the request was changed, copy over the id and timestamp from the original. transformed.id = id; transformed.started = started; if (loggingEnabled) &#123; log(OWNER_MAIN, VERB_CHANGED, transformed.logId(), &quot;into &quot; + transformed); &#125; &#125; // 返回Request return transformed; &#125;上述主要分析了PicassoProvider.get().load(“url”).into(imageview)整体流程。Dispatcher处理请求流程前面分析into方法的最后，图片以Action的形式加入Picasso请求：12345picasso.enqueueAndSubmit(action)void submit(Action action) &#123; dispatcher.dispatchSubmit(action);&#125;请求加入Dispatcher中，然后放到Handler进行处理。123void dispatchSubmit(Action action) &#123; handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));&#125;Dispatcher核心是DispatcherThread、DispatcherHandler、PicassoExecutorService。DispatcherThread是一个HandlerThread，HandlerThread有自己的内部Looper对象，将Message发送给DispatcherHandler在handleMessage进行处理。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private static class DispatcherHandler extends Handler &#123; private final Dispatcher dispatcher; DispatcherHandler(Looper looper, Dispatcher dispatcher) &#123; super(looper); this.dispatcher = dispatcher; &#125; @Override public void handleMessage(final Message msg) &#123; switch (msg.what) &#123; // 提交请求 case REQUEST_SUBMIT: &#123; Action action = (Action) msg.obj; dispatcher.performSubmit(action); break; &#125; // 取消请求 case REQUEST_CANCEL: &#123; Action action = (Action) msg.obj; dispatcher.performCancel(action); break; &#125; // 暂停请求 case TAG_PAUSE: &#123; Object tag = msg.obj; dispatcher.performPauseTag(tag); break; &#125; // 恢复请求 case TAG_RESUME: &#123; Object tag = msg.obj; dispatcher.performResumeTag(tag); break; &#125; // hunter完成 case HUNTER_COMPLETE: &#123; BitmapHunter hunter = (BitmapHunter) msg.obj; dispatcher.performComplete(hunter); break; &#125; // hunter重试 case HUNTER_RETRY: &#123; BitmapHunter hunter = (BitmapHunter) msg.obj; dispatcher.performRetry(hunter); break; &#125; // hunter解码失败 case HUNTER_DECODE_FAILED: &#123; BitmapHunter hunter = (BitmapHunter) msg.obj; dispatcher.performError(hunter); break; &#125; // 网络状态变更 case NETWORK_STATE_CHANGE: &#123; NetworkInfo info = (NetworkInfo) msg.obj; dispatcher.performNetworkStateChange(info); break; &#125; // 飞行模式变更 case AIRPLANE_MODE_CHANGE: &#123; dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON); break; &#125; default: Picasso.HANDLER.post(new Runnable() &#123; @Override public void run() &#123; throw new AssertionError(&quot;Unknown handler message received: &quot; + msg.what); &#125; &#125;); &#125; &#125; &#125;再来看看Dispathcer的perormSubmit方法。12345678910111213void performSubmit(Action action, boolean dismissFailed) &#123; // 前面是做一些必要的判断处理 ... // 获取Action的Hunter hunter = forRequest(action.getPicasso(), this, cache, stats, action); // 将Hunter加入线程池 hunter.future = service.submit(hunter); // 存入hunterMap中 hunterMap.put(action.getKey(), hunter); ...&#125;service即PicassoExecutorService，是Picasso实现基于优先级队列PriorityBlockingQueue的线程池，继承于ThreadPoolExecutor，内部有一个FutureTask实现类PicassoFutureTask。PicassoFutureTask通过compareTo方法比较请求的优先级，具体实现在其内部持有的BitmapHunter内部。BitmapHunter是Runnable子类，具体作用就是“狩猎”bitmap，返回一个持有bitmap的Result。service.submit(hunter)即是将FutureTask提交到线程池处理，返回一个Future，此处之所以用FutureTask，是用于监听hunter是否执行完毕且可以cancel执行。BitmapHunter其核心是run里的hunt方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Result hunt() throws IOException &#123; // 缓存命中则直接获取Result返回 if (shouldReadFromMemoryCache(data.memoryPolicy)) &#123; Bitmap bitmap = cache.get(key); if (bitmap != null) &#123; stats.dispatchCacheHit(); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_DECODED, data.logId(), &quot;from cache&quot;); &#125; return new Result(bitmap, MEMORY); &#125; &#125; ... // RequestHandler即最开始提的8种请求处理，根据图片来源的不同进行处理 final CountDownLatch latch = new CountDownLatch(1); try &#123; requestHandler.load(picasso, data, new RequestHandler.Callback() &#123; @Override public void onSuccess(@Nullable Result result) &#123; resultReference.set(result); latch.countDown(); &#125; @Override public void onError(@NonNull Throwable t) &#123; exceptionReference.set(t); latch.countDown(); &#125; &#125;); latch.await(); &#125; catch (InterruptedException ie) &#123; InterruptedIOException interruptedIoException = new InterruptedIOException(); interruptedIoException.initCause(ie); throw interruptedIoException; &#125; ... Result result = resultReference.get(); Bitmap bitmap = result.getBitmap(); if (bitmap != null) &#123; if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_DECODED, data.logId()); &#125; // 解码bitmap stats.dispatchBitmapDecoded(bitmap); // 做Transformation变换处理 List&lt;Transformation&gt; transformations = new ArrayList&lt;&gt;(data.transformations.size() + 1); if (data.needsMatrixTransform() || result.getExifRotation() != 0) &#123; transformations.add(new MatrixTransformation(data)); &#125; transformations.addAll(data.transformations); result = applyTransformations(picasso, data, transformations, result); bitmap = result.getBitmap(); if (bitmap != null) &#123; stats.dispatchBitmapTransformed(bitmap); &#125; // 返回Result return result;&#125;run方法再将处理的结果发送回Dispathcer，例如dispatchComplete和dispatchFailed。Dispathcer里还维护了一个主线程Handler，mainThreadHandler，在Picasso类实现传入。前面处理的结果最终会通过一个deliver方法传回mainThreadHandler，通过回调监听返回listener返回给Picasso使用方，即App。至此，Picasso主要流程分析完毕。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android P使用私有API弹出warning]]></title>
    <url>%2Farchives%2F35fd3a81.html</url>
    <content type="text"><![CDATA[最近手头的Mix2s接收到MIUI官方开发版的推送，可以升级为Android P，很开心，然后升级后，部分应用就打不开或者挂了，比如某奇艺（买了VIP看剧都看不了，强烈吐槽）。于是顺手检查了一下公司的应用，发现都能正常启动和使用，但是最近在做SDK的接入Demo，一打开发现弹出了warning对话框：起初以为是targetAPI的问题，升级到28问题依旧，于是Google了一下，发现是从Android P开始，系统会限制非SDK的接口调用，也就是如果App通过反射使用系统隐藏的API，则会弹出提示。具体的细节可参考：https://developer.android.com/about/versions/pie/restrictions-non-sdk-interfaces?hl=zh-cnAndroid P中，将所有API分为以下几类：白名单：SDK的API，正常使用；浅灰名单（light greylist）会在logcat弹出提示：Accessing hidden field Landroid/os/Message;-&gt;flags:I (light greylist, JNI)；深灰名单（dark greylist）则debug版本在会弹出dialog提示框，在release版本会有Toast提示，均提示为”Detected problems with API compatibility”。；黑名单(darklist)则会引发异常。看了logcat日志，项目中许多地方使用到了系统私有API，直接全部修改工作量比较大，于是寻找解决方案。最后发现原因是在SDK 28版本中Activity中的performStart有这个警告，只要在调用performStart前，ActivityThread的mHiddenApiWarningShown变量的值为true，产生这个警告的条件就无法满足。1234567891011121314151617181920212223boolean isAppDebuggable = (mApplication.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0;// This property is set for all non-user builds except final releaseboolean isApiWarningEnabled = SystemProperties.getInt(&quot;ro.art.hiddenapi.warning&quot;, 0) == 1;if (isAppDebuggable || isApiWarningEnabled) &#123; if (!mMainThread.mHiddenApiWarningShown &amp;&amp; VMRuntime.getRuntime().hasUsedHiddenApi()) &#123; // Only show the warning once per process. mMainThread.mHiddenApiWarningShown = true; String appName = getApplicationInfo().loadLabel(getPackageManager()) .toString(); String warning = &quot;Detected problems with API compatibility\n&quot; + &quot;(visit g.co/dev/appcompat for more info)&quot;; if (isAppDebuggable) &#123; new AlertDialog.Builder(this) .setTitle(appName) .setMessage(warning) .setPositiveButton(android.R.string.ok, null) .setCancelable(false) .show(); &#125; else &#123; Toast.makeText(this, appName + &quot;\n&quot; + warning, Toast.LENGTH_LONG).show(); &#125; &#125;&#125;具体是在Application OnCreate加入以下代码：（通过反射私有变量来解决私有API的warning，也是有趣）1234567891011try &#123; Class&lt;?&gt; cls = Class.forName(&quot;android.app.ActivityThread&quot;); Method declaredMethod = cls.getDeclaredMethod(&quot;currentActivityThread&quot;); declaredMethod.setAccessible(true); Object activityThread = declaredMethod.invoke(null); Field mHiddenApiWarningShown = cls.getDeclaredField(&quot;mHiddenApiWarningShown&quot;); mHiddenApiWarningShown.setAccessible(true); mHiddenApiWarningShown.setBoolean(activityThread, true);&#125; catch (Exception e) &#123; e.printStackTrace();&#125;最终warning框不再弹出，但是logcat依旧，在Logcat中看到，修改mHiddenApiWarningShown本身就是dark greylist，估计后续该办法会给官方禁用。最好的解决方式是根据logcat的warning提示，对使用darklist的地方必须进行修改，尽量避免使用dark greylist方法。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android组件化初探]]></title>
    <url>%2Farchives%2F22258b7f.html</url>
    <content type="text"><![CDATA[组件化的优势：代码架构更加清晰，降低项目的维护难度；组件模式下可以加快编译速度，提高开发效率；项目比较大的情况下，多团队独立开发不同模块，互不影响；利于向插件化变更。架构：App壳工程与具体的业务无关，作为门面封装入口。Module实现具体的模块功能，Module之间解耦合，组件可独立于App壳工程单独运行。Common用于存放公用资源，例如res、工具类，公用第三方library等，各Module依赖于Common。Demohttps://github.com/huangyu/ComponentDemo组件模式和集成模式gradle.properties中配置isModule=false，通过if(isModule.toBoolean())判断是否是组件模式。注意：每次更改“isModule”的值后，需要点击 “Sync Project” 按钮。在组件的build.gradle中，区分当前Module是组件模式还是集成模式。12345if (isModule.toBoolean()) &#123; apply plugin: &apos;com.android.application&apos;&#125; else &#123; apply plugin: &apos;com.android.library&apos;&#125;AndroidManifest和Application文件问题12345678910111213sourceSets &#123; main &#123; if (isModule.toBoolean()) &#123; manifest.srcFile &apos;src/main/module/AndroidManifest.xml&apos; &#125; else &#123; manifest.srcFile &apos;src/main/AndroidManifest.xml&apos; // 集成开发模式下排除debug文件夹中的所有Java文件 java &#123; exclude &apos;library/**&apos; &#125; &#125; &#125;&#125;每个使用两份AndroidManifest.xml：一个用于集成模式，即定义内部组件、权限等信息，不包含Application信息和启动类信息。一个用于组件模式，包含Application信息和启动类信息，可用于组件单独运行。组件的Application放置于java/library目录，基于Common库的BaseApplication，集成模式打包不加入。业务组件自己的 Application 可以在组件开发模式下初始化一些数据，Common 组件初始化公用数据，例如全局Context等。资源冲突资源重名，比如App壳工程有资源和Module重名，则会覆盖Module同名资源，造成显示不准确。利用resourcePrefix “prefix_”在资源名加前缀可避免重名问题。设置了resourcePrefix值后，所有的资源名必须以指定的字符串做前缀，否则会报错。resourcePrefix这个值只能限定xml里面的资源，并不能限定图片资源，所有图片资源仍然需要手动去修改资源名。library 重复依赖不同Module都依赖了Common，会不会导致 library 重复依赖呢？实际上在 release 构建 APP 的过程中 Gradle 会自动将重复的 aar 包排除，因此不存在此问题。混淆问题一般对于开源的第三方库，没有加入混淆的必要；对于部分闭源的项目，如果需要可用consumerProguardFiles对核心代码和算法进行混淆。我们自己的项目使用，Module间没有混淆代码的必要（不同开发小组没有必要相互隐藏代码实现吧），统一在App里混淆即可。组件通信组件间通信包括三个场景：（1）UI 跳转；（2）调用组件某个类的某个方法； （3）事件通知前两个场景建议使用强大的路由库：https://github.com/alibaba/ARouterUI跳转使用方式：通过@Route定义Activity或者Fragment的路径使用ARouter.getInstance().build(“url”).navigation()进行跳转如果模块没有集成进来，想要跳转到这个页面的时候，不会崩溃，设置debug模式的时候会出现找不到的提示，而点击属于这个模块的功能的时候则不会有反应。在没有ARouter或者其他类似的路由库的时候，我们想从组件间进行Activity跳转，怎么处理？答案就是：反射！只要知道对应要跳转的Activity包名全路径，反射即可获取对应的Activity类，即可进行跳转。那么我们可以构造一个全局的Map，Map的key是路径，value是具体的类信息，即可实现全局的管理。另外，需要了解APT：APT技术可以让我们通过自定义注解动态生成编译后的class代码，ARoute里使用了APT去生成注解处理文件。ARouter背后的原理是怎么样的呢？实际上它的核心思想跟上面讲解的是一样的。1.在Activity定义@Route注解，会在编译时期通过APT生成一些存储path和activityClass映射关系的类文件。2.ARoute.init()在app进程启动的时候会拿到这些类文件，把保存这些映射关系的数据保存在map里。3.通过build()方法传入要到达页面的路由地址，ARouter会通过它自己存储的路由表找到路由地址对应的Activity.class(activity.class = map.get(path))，然后new Intent()4.当调用ARouter的withString()等方法它的内部会调用intent.putExtra(String name, String value)存放传递参数。5.调用navigation()方法，它的内部会调用startActivity(intent)进行跳转，这样便可以实现两个相互没有依赖的module顺利的启动对方的Activity了。ARoute的基本思想是这样，当然了ARoute还做了其他很多处理，例如@Interceptor的AOP，@Autowired的依赖注入等，不详细赘述。调用组件某个类某个方法这里参考ARoute的README文档：通过依赖注入解耦:服务管理(一) 暴露服务12345678910111213141516171819// 声明接口,其他组件通过接口来调用服务public interface HelloService extends IProvider &#123; String sayHello(String name);&#125;// 实现接口@Route(path = &quot;/service/hello&quot;, name = &quot;测试服务&quot;)public class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return &quot;hello, &quot; + name; &#125; @Override public void init(Context context) &#123; &#125;&#125;通过依赖注入解耦:服务管理(二) 发现服务12345678910111213141516171819202122232425262728public class Test &#123; @Autowired HelloService helloService; @Autowired(name = &quot;/service/hello&quot;) HelloService helloService2; HelloService helloService3; HelloService helloService4; public Test() &#123; ARouter.getInstance().inject(this); &#125; public void testService() &#123; // 1. (推荐)使用依赖注入的方式发现服务,通过注解标注字段,即可使用，无需主动获取 // Autowired注解中标注name之后，将会使用byName的方式注入对应的字段，不设置name属性，会默认使用byType的方式发现服务(当同一接口有多个实现的时候，必须使用byName的方式发现服务) helloService.sayHello(&quot;Vergil&quot;); helloService2.sayHello(&quot;Vergil&quot;); // 2. 使用依赖查找的方式发现服务，主动去发现服务并使用，下面两种方式分别是byName和byType helloService3 = ARouter.getInstance().navigation(HelloService.class); helloService4 = (HelloService) ARouter.getInstance().build(&quot;/service/hello&quot;).navigation(); helloService3.sayHello(&quot;Vergil&quot;); helloService4.sayHello(&quot;Vergil&quot;); &#125;&#125;事件通知：第三个场景可使用Android的本地广播或者EventBus：https://github.com/greenrobot/EventBus定义事件：1public static class MessageEvent &#123; /* Additional fields if needed */ &#125;事件响应：12@Subscribe(threadMode = ThreadMode.MAIN) public void onMessageEvent(MessageEvent event) &#123;/* Do something */&#125;;注册EventBus：1234567891011@Overridepublic void onStart() &#123; super.onStart(); EventBus.getDefault().register(this);&#125;@Overridepublic void onStop() &#123; super.onStop(); EventBus.getDefault().unregister(this);&#125;发送事件：1EventBus.getDefault().post(new MessageEvent());]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理和注解处理接口Token问题]]></title>
    <url>%2Farchives%2Fcdd0265b.html</url>
    <content type="text"><![CDATA[背景目前在做SDK时，网络层使用的框架是OkHttp + Retrofit，需要对外提供API方式的网络接口调用。一般来说，后台都会有接口校验设计，需要在请求头包含部分加密参数进行验证。我们的项目也是这样处理，外放的接口需要先调用登录接口获取Token，根据Token在请求头进行组合形成鉴权，才能成功通过后台的校验进行使用。这时候想，如果每个接口都需要提前先获取Token，工作量非常大，于是想到了类似Java的AOP的面向切面处理方式，使用动态代理灵活在接口方法前插入获取Token逻辑。而部分接口例如，获取验证码、登录相关的，并不需要Token，因此再自定义一个注解用于区别。动态代理要理解动态代理首先要理解代理，代理：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。代理有什么用呢？举个例子，上大学偶尔舍友会不想上他自己的课，于是让我去代签名，此时我就成为了这个舍友的代理，替他去上课。一般来说，我们使用聚合方式让代理类持有一个被代理类对象，即可实现代理，而此种方式一般称为静态代理。在项目中我们有一个Repository实现了具体的网络接口请求，里面有许多接口方法，如下所示：123456public class Repository implements IRepository &#123; void method1() &#123;...&#125; void method2() &#123;...&#125; void method3() &#123;...&#125; ... &#125;目前我们想要有一个Repository的Proxy类，在每个接口前加入获取Token的逻辑，如果用静态代理来做，如下：12345678910111213141516171819public class RepositoryProxy implements IRepository &#123; IRepository repository; void method1() &#123; getToken(); repository.method1(); &#125; void method2() &#123; getToken(); repository.method2(); &#125; void method3() &#123; getToken(); repository.method3(); &#125; ... void getToken() &#123;...&#125;&#125;可以看到每个接口前都需要调用getToken，同样的逻辑需要反复实现，虽然效果达到了，但是由此写了很多重复的代码，因此静态代理也不适用于我们的需求。于是使用动态代理来实现，这样就达到了预期的效果，如下：1234567891011121314public class RepositoryInvocationHandler implements InvocationHandler &#123; IRepository repository; @Override public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable &#123; if(如果需要Token) &#123; getToken(); &#125; return method.invoke(repository, args); &#125; void getToken() &#123;...&#125;&#125;具体是实现InvocationHandler接口，覆写invoke方法，method.invoke(repository, args)即等价于调用IRepository的网络请求接口，在此方法前可以插入自定义逻辑。在原本需要调用Repository的地方生成动态代理方式，如下：123Repository repository = new Repository();RepositoryInvocationHandler repositoryInvocationHandler = new RepositoryInvocationHandler(repository);proxy = (IRepository) (Proxy.newProxyInstance(IRepository.class.getClassLoader(), new Class[]&#123;IRepository.class&#125;, repositoryInvocationHandler));注解注解（也被成为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。 ———摘自《Thinking in Java》简单来说注解的作用就是将我们的需要的数据储存起来，在以后的某一个时刻（可能是编译时，也可能是运行时）去调用它。在我们的项目中，针对部分接口不需要Token的，处理逻辑不同，于是通过自定义注解实现，如下：1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface NeedToken &#123;&#125;在Repository中，对需要获取Token的方法前加@NeedToken即可。最后修改InvocationHandler的逻辑，如下：1234567891011121314151617public class RepositoryInvocationHandler implements InvocationHandler &#123; IRepository repository; @Override public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable &#123; // 如果带NeedToken有注解，先判断是否获取了Token，否则需要获取，再调用API方法 NeedToken isNeedToken = method.getAnnotation(NeedToken.class); if(isNeedToken != null) &#123; getToken(); &#125; // 否则直接调用方法即可 return method.invoke(repository, args); &#125; void getToken() &#123;...&#125;&#125;另外，由于getToken一般也为一个接口方法，需要异步回调获取Token，需注意RepositoryInvocationHandler类不能写成单例，应该每个接口方法对应一个proxy，对应一个获取Token回调，否则会造成冲突。Done.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SlidingCheckLayout滑动选择布局实现]]></title>
    <url>%2Farchives%2F2720d64c.html</url>
    <content type="text"><![CDATA[背景项目需求，要求在选择本地图片时，可对图片进行滑动选择。类似小米图库或者图库，现在很多手机系统内置图库都自带了这个功能。最后经过调研，使用自定义View解决。SlidingCheckLayout滑动选择布局，用于嵌套RecyclerView实现滑动选择功能。效果如图所示：最后将代码整理了一下，并上传到Jitpack。源码https://github.com/huangyu/SlidingCheckLayout引用方式在根目录：123456allprojects &#123; repositories &#123; ... maven &#123; url &apos;https://jitpack.io&apos; &#125; &#125;&#125;添加依赖：1234dependencies &#123; ... implementation &apos;com.github.huangyu0:SlidingCheckLayout:x.x.x&apos;&#125;使用方法在layout的xml中，在RecyclerView外层嵌套SlidingCheckLayout作为唯一子节点。在App中实现SlidingCheckLayout.OnSlidingCheckListener接口即可，具体可参考Demo工程。原理通过onInterceptTouchEvent方法拦截滑动请求，找到起始点坐标。12345678// 计算起始点坐标View child = targetRlv.findChildViewUnder(ev.getX(), ev.getY());if (child != null) &#123; int position = targetRlv.getChildAdapterPosition(child); if (position != RecyclerView.*NO_POSITION*&amp;&amp; startPos != position) &#123; startPos = position; &#125;&#125;RecycleView的findChildViewUnder()方法，可以十分方便返回指定位置的childView。判断是否处于滑动状态，xTouchSlop和yTouchSlop为横向和纵向两个阈值。12345float xDiff = Math.*abs*(ev.getX() - startX);float yDiff = Math.*abs*(ev.getY() - startY);if (yDiff &lt; yTouchSlop &amp;&amp; xDiff &gt; xTouchSlop) &#123; isSliding = true;&#125;为了和RecycleView的Item点击事件不冲突，通过自定义一个判断标记isSliding，返回是否拦截滑动请求，即是否进行了滑动选择。通过onTouchEvent处理具体的拦截逻辑。12345678910111213141516171819202122@Overridepublic boolean onTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.*ACTION_DOWN*: break; case MotionEvent.*ACTION_MOVE*: if (!inTopSpot &amp;&amp; !inBottomSpot) &#123; // 处理滑动事件 updateSelectedRange(targetRlv, ev); &#125; // 在顶部或者底部触发自动滑动 processAutoScroll(ev); break; case MotionEvent.*ACTION_UP*: resetParams(); stopAutoScroll(); performClick(); return false; &#125; return isSliding;&#125;既然是滑动，处理事件肯定是在ACTION_MOVE里。这里的inTopSpot和inBottomSpot两个标记用于计算是否滑动到顶部或者底部，用于滑动到顶部或者底部时，使用Scroller进行自动滚动。具体实现在processAutoScroll方法。updateSelectedRange则处理滑动选择。12345678910private void updateSelectedRange(RecyclerView rv, float x, float y) &#123; View child = rv.findChildViewUnder(x, y); if (child != null) &#123; int position = rv.getChildAdapterPosition(child); if (position != RecyclerView.*NO_POSITION*&amp;&amp; endPos != position) &#123; endPos = position; notifySelectRangeChange(); &#125; &#125;&#125;这里同样用findChildViewUnder方法记录结束标志，现在获取到了起始点和结束点。12345678910111213141516171819202122232425262728293031private void notifySelectRangeChange() &#123; if (onSlidingCheckListener == null) &#123; return; &#125; if (startPos == RecyclerView.*NO_POSITION*|| endPos == RecyclerView.*NO_POSITION*) &#123; return; &#125; int newStart, newEnd; newStart = Math.*min*(startPos, endPos); newEnd = Math.*max*(startPos, endPos); if (lastStartPos == RecyclerView.*NO_POSITION*|| lastEndPos == RecyclerView.*NO_POSITION*) &#123; onSlidingCheckListener.onSlidingCheckPos(newStart, newEnd); &#125; else &#123; if (newStart &gt; lastStartPos) &#123; onSlidingCheckListener.onSlidingCheckPos(lastStartPos, newStart - 1); &#125; else if (newStart &lt; lastStartPos) &#123; onSlidingCheckListener.onSlidingCheckPos(newStart, lastStartPos - 1); &#125; if (newEnd &gt; lastEndPos) &#123; onSlidingCheckListener.onSlidingCheckPos(lastEndPos + 1, newEnd); &#125; else if (newEnd &lt; lastEndPos) &#123; onSlidingCheckListener.onSlidingCheckPos(newEnd + 1, lastEndPos); &#125; &#125; lastStartPos = newStart; lastEndPos = newEnd;&#125;notifySelectRangeChange为核心处理逻辑，通过当前滑动的起始点和终点计算中间滑动的范围并回调给调用方。这里自定义了一个回调接口类：123public interface OnSlidingCheckListener &#123; void onSlidingCheckPos(int startPos, int endPos);&#125;最后外部使用回调对起始点至终点部分进行选择处理。123456789101112131415scl.setOnSlidingCheckListener(new SlidingCheckLayout.OnSlidingCheckListener() &#123; @Override public void onSlidingCheckPos(int startPos, int endPos) &#123; RecyclerView recyclerView = (RecyclerView) scl.getChildAt(0); for (int I = startPos; I &lt;= endPos; I++) &#123; View current = recyclerView.getLayoutManager().findViewByPosition(i); if (current != null) &#123; View currentLayout = current.findViewById(R.id.*rl_root*); if (currentLayout != null) &#123; currentLayout.performClick(); &#125; &#125; &#125; &#125;&#125;);Done.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法汇总]]></title>
    <url>%2Farchives%2F3c50d03d.html</url>
    <content type="text"><![CDATA[Markdown语法汇总标题使用#，可表示1-6级标题。一级标题二级标题三级标题四级标题五级标题六级标题无序列表使用·、+、或-标记无序列表。注意：标记后面最少有一个_空格_或制表符。若不在引用区块中，必须和前方段落之间存在空行。无序列表1无序列表2无序列表3有序列表有序列表的标记方式是将上述的符号换成数字,并辅以.。有序列表1有序列表2有序列表3强调在强调内容两侧分别加上*或者_。斜体_斜体加粗加粗段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用。引用嵌套引用代码代码区块的建立是在每行加上4个空格或者一个制表符。void main() { printf(&quot;Hello, Markdown.&quot;); } 或者使用上下三个`包裹。1234void main()&#123; printf(&quot;Hello, Markdown.&quot;);&#125;分割线分割线最常使用就是三个或以上*，还可以使用-和_。链接，[]内为描述信息，()为链接地址。huangyu的随记随想图片添加图片的形式和链接相似，只需在链接的基础上前方加一个!。转义\相当于反转义作用。使符号成为普通符号。标记`符号起到标记作用。标记表格在 Markdown 中，可以制作表格。1234First Header | Second Header | Third Header------------ | ------------- | ------------Content Cell | Content Cell | Content CellContent Cell | Content Cell | Content CellFirst HeaderSecond HeaderThird HeaderContent CellContent CellContent CellContent CellContent CellContent Cell或者也可以让表格两边内容对齐，中间内容居中。1234First Header | Second Header | Third Header:----------- | :-----------: | -----------:Left | Center | RightLeft | Center | RightFirst HeaderSecond HeaderThird HeaderLeftCenterRightLeftCenterRight]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
