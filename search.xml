<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SlidingCheckLayout滑动选择布局实现]]></title>
    <url>%2Farchives%2F2720d64c.html</url>
    <content type="text"><![CDATA[背景项目中有需求，要求在选择本地图片时，可对图片进行滑动选择。类似小米图库或者图库，现在很多手机系统内置图库都自带了这个功能。最后经过调研，使用自定义View解决。SlidingCheckLayout滑动选择布局，用于嵌套RecyclerView实现滑动选择功能。效果如图所示：最后将代码整理了一下，并上传到Jitpack。源码https://github.com/huangyu/SlidingCheckLayout引用方式在根目录：123456allprojects &#123; repositories &#123; ... maven &#123; url &apos;https://jitpack.io&apos; &#125; &#125;&#125;添加依赖：1234dependencies &#123; ... implementation &apos;com.github.huangyu0522:SlidingCheckLayout:1.0.2&apos;&#125;使用方法在layout的xml中，在RecyclerView外层嵌套SlidingCheckLayout作为唯一子节点。在App中实现SlidingCheckLayout.OnSlidingCheckListener接口即可，具体可参考Demo工程。原理通过onInterceptTouchEvent方法拦截滑动请求，找到起始点坐标。12345678// 计算起始点坐标View child = targetRlv.findChildViewUnder(ev.getX(), ev.getY());if (child != null) &#123; int position = targetRlv.getChildAdapterPosition(child); if (position != RecyclerView.*NO_POSITION*&amp;&amp; startPos != position) &#123; startPos = position; &#125;&#125;RecycleView的findChildViewUnder()方法，可以十分方便返回指定位置的childView。判断是否处于滑动状态，xTouchSlop和yTouchSlop为横向和纵向两个阈值。12345float xDiff = Math.*abs*(ev.getX() - startX);float yDiff = Math.*abs*(ev.getY() - startY);if (yDiff &lt; yTouchSlop &amp;&amp; xDiff &gt; xTouchSlop) &#123; isSliding = true;&#125;为了和RecycleView的Item点击事件不冲突，通过自定义一个判断标记isSliding，返回是否拦截滑动请求，即是否进行了滑动选择。通过onTouchEvent处理具体的拦截逻辑。12345678910111213141516171819202122@Overridepublic boolean onTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.*ACTION_DOWN*: break; case MotionEvent.*ACTION_MOVE*: if (!inTopSpot &amp;&amp; !inBottomSpot) &#123; // 处理滑动事件 updateSelectedRange(targetRlv, ev); &#125; // 在顶部或者底部触发自动滑动 processAutoScroll(ev); break; case MotionEvent.*ACTION_UP*: resetParams(); stopAutoScroll(); performClick(); return false; &#125; return isSliding;&#125;既然是滑动，处理事件肯定是在ACTION_MOVE里。这里的inTopSpot和inBottomSpot两个标记用于计算是否滑动到顶部或者底部，用于滑动到顶部或者底部时，使用Scroller进行自动滚动。具体实现在processAutoScroll方法。updateSelectedRange则处理滑动选择。12345678910private void updateSelectedRange(RecyclerView rv, float x, float y) &#123; View child = rv.findChildViewUnder(x, y); if (child != null) &#123; int position = rv.getChildAdapterPosition(child); if (position != RecyclerView.*NO_POSITION*&amp;&amp; endPos != position) &#123; endPos = position; notifySelectRangeChange(); &#125; &#125;&#125;这里同样用findChildViewUnder方法记录结束标志，现在获取到了起始点和结束点。1234567891011121314151617181920212223242526272829303132333435private void notifySelectRangeChange() &#123; if (onSlidingCheckListener == null) &#123; return; &#125; if (startPos == RecyclerView.*NO_POSITION*|| endPos == RecyclerView.*NO_POSITION*) &#123; return; &#125; int newStart, newEnd; newStart = Math.*min*(startPos, endPos); newEnd = Math.*max*(startPos, endPos); if (lastStartPos == RecyclerView.*NO_POSITION*|| lastEndPos == RecyclerView.*NO_POSITION*) &#123; if (newEnd - newStart == 1) &#123; onSlidingCheckListener.onSlidingCheckPos(newStart, newStart); &#125; else &#123; onSlidingCheckListener.onSlidingCheckPos(newStart, newEnd); &#125; &#125; else &#123; if (newStart &gt; lastStartPos) &#123; onSlidingCheckListener.onSlidingCheckPos(lastStartPos, newStart - 1); &#125; else if (newStart &lt; lastStartPos) &#123; onSlidingCheckListener.onSlidingCheckPos(newStart, lastStartPos - 1); &#125; if (newEnd &gt; lastEndPos) &#123; onSlidingCheckListener.onSlidingCheckPos(lastEndPos + 1, newEnd); &#125; else if (newEnd &lt; lastEndPos) &#123; onSlidingCheckListener.onSlidingCheckPos(newEnd + 1, lastEndPos); &#125; &#125; lastStartPos = newStart; lastEndPos = newEnd;&#125;notifySelectRangeChange为核心处理逻辑，通过当前滑动的起始点和终点计算中间滑动的范围并回调给调用方。这里自定义了一个回调接口类：123456789101112*/**** * 回调接口** */*public interface OnSlidingCheckListener &#123; */**** * 回调选择事件** *** ****@param***startPos 第一个item** ****@param***endPos 最后一个item** */*void onSlidingCheckPos(int startPos, int endPos);&#125;最后外部使用回调对起始点至终点部分进行选择处理。123456789101112131415scl.setOnSlidingCheckListener(new SlidingCheckLayout.OnSlidingCheckListener() &#123; @Override public void onSlidingCheckPos(int startPos, int endPos) &#123; RecyclerView recyclerView = (RecyclerView) scl.getChildAt(0); for (int I = startPos; I &lt;= endPos; I++) &#123; View current = recyclerView.getLayoutManager().findViewByPosition(i); if (current != null) &#123; View currentLayout = current.findViewById(R.id.*rl_root*); if (currentLayout != null) &#123; currentLayout.performClick(); &#125; &#125; &#125; &#125;&#125;);Done.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2Farchives%2F3c50d03d.html</url>
    <content type="text"><![CDATA[标题使用#，可表示1-6级标题。一级标题二级标题三级标题四级标题五级标题六级标题无序列表使用·、+、或-标记无序列表。注意：标记后面最少有一个_空格_或制表符。若不在引用区块中，必须和前方段落之间存在空行。无序列表1无序列表2无序列表3有序列表有序列表的标记方式是将上述的符号换成数字,并辅以.。有序列表1有序列表2有序列表3强调在强调内容两侧分别加上*或者_。斜体_斜体加粗加粗段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用。引用嵌套引用代码代码区块的建立是在每行加上4个空格或者一个制表符。void main() { printf(&quot;Hello, Markdown.&quot;); } 或者使用上下三个`包裹。1234void main()&#123; printf(&quot;Hello, Markdown.&quot;);&#125;分割线分割线最常使用就是三个或以上*，还可以使用-和_。链接，[]内为描述信息，()为链接地址。huangyu的随记随想图片添加图片的形式和链接相似，只需在链接的基础上前方加一个!。转义\相当于反转义作用。使符号成为普通符号。标记`符号起到标记作用。标记表格在 Markdown 中，可以制作表格。1234First Header | Second Header | Third Header------------ | ------------- | ------------Content Cell | Content Cell | Content CellContent Cell | Content Cell | Content CellFirst HeaderSecond HeaderThird HeaderContent CellContent CellContent CellContent CellContent CellContent Cell或者也可以让表格两边内容对齐，中间内容居中。1234First Header | Second Header | Third Header:----------- | :-----------: | -----------:Left | Center | RightLeft | Center | RightFirst HeaderSecond HeaderThird HeaderLeftCenterRightLeftCenterRight]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
