<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android组件化初探]]></title>
    <url>%2Farchives%2F22258b7f.html</url>
    <content type="text"><![CDATA[组件化的优势：代码架构更加清晰，降低项目的维护难度；组件模式下可以加快编译速度，提高开发效率；项目比较大的情况下，多团队独立开发不同模块，互不影响；利于向插件化变更。架构：App壳工程与具体的业务无关，作为门面封装入口。Module实现具体的模块功能，Module之间解耦合，组件可独立于App壳工程单独运行。Common用于存放公用资源，例如res、工具类，公用第三方library等，各Module依赖于Common。Demohttps://github.com/huangyu/ComponentDemo组件模式和集成模式gradle.properties中配置isModule=false，通过if(isModule.toBoolean())判断是否是组件模式。注意：每次更改“isModule”的值后，需要点击 “Sync Project” 按钮。在组件的build.gradle中，区分当前Module是组件模式还是集成模式。12345if (isModule.toBoolean()) &#123; apply plugin: &apos;com.android.application&apos;&#125; else &#123; apply plugin: &apos;com.android.library&apos;&#125;AndroidManifest和Application文件问题12345678910111213sourceSets &#123; main &#123; if (isModule.toBoolean()) &#123; manifest.srcFile &apos;src/main/module/AndroidManifest.xml&apos; &#125; else &#123; manifest.srcFile &apos;src/main/AndroidManifest.xml&apos; // 集成开发模式下排除debug文件夹中的所有Java文件 java &#123; exclude &apos;library/**&apos; &#125; &#125; &#125;&#125;每个使用两份AndroidManifest.xml：一个用于集成模式，即定义内部组件、权限等信息，不包含Application信息和启动类信息。一个用于组件模式，包含Application信息和启动类信息，可用于组件单独运行。组件的Application放置于java/library目录，基于Common库的BaseApplication，集成模式打包不加入。业务组件自己的 Application 可以在组件开发模式下初始化一些数据，Common 组件初始化公用数据，例如全局Context等。资源冲突资源重名，比如App壳工程有资源和Module重名，则会覆盖Module同名资源，造成显示不准确。利用resourcePrefix “prefix_”在资源名加前缀可避免重名问题。设置了resourcePrefix值后，所有的资源名必须以指定的字符串做前缀，否则会报错。resourcePrefix这个值只能限定xml里面的资源，并不能限定图片资源，所有图片资源仍然需要手动去修改资源名。library 重复依赖不同Module都依赖了Common，会不会导致 library 重复依赖呢？实际上在 release 构建 APP 的过程中 Gradle 会自动将重复的 aar 包排除，因此不存在此问题。混淆问题一般对于开源的第三方库，没有加入混淆的必要；对于部分闭源的项目，如果需要可用consumerProguardFiles对核心代码和算法进行混淆。我们自己的项目使用，Module间没有混淆代码的必要（不同开发小组没有必要相互隐藏代码实现吧），统一在App里混淆即可。组件通信组件间通信包括三个场景：（1）UI 跳转；（2）调用组件某个类的某个方法； （3）事件通知前两个场景建议使用强大的路由库：https://github.com/alibaba/ARouterUI跳转使用方式：通过@Route定义Activity或者Fragment的路径使用ARouter.getInstance().build(“url”).navigation()进行跳转在没有ARouter或者其他类似的路由库的时候，我们想从组件间进行Activity跳转，怎么处理？答案就是：反射！只要知道对应要跳转的Activity包名全路径，反射即可获取对应的Activity类，即可进行跳转。那么我们可以构造一个全局的Map，Map的key是路径，value是具体的类信息，即可实现全局的管理。另外，需要了解APT：APT技术可以让我们通过自定义注解动态生成编译后的class代码，ARoute里使用了APT去生成注解处理文件。ARouter背后的原理是怎么样的呢？实际上它的核心思想跟上面讲解的是一样的。1.在Activity定义@Route注解，会在编译时期通过APT生成一些存储path和activityClass映射关系的类文件。2.ARoute.init()在app进程启动的时候会拿到这些类文件，把保存这些映射关系的数据保存在map里。3.通过build()方法传入要到达页面的路由地址，ARouter会通过它自己存储的路由表找到路由地址对应的Activity.class(activity.class = map.get(path))，然后new Intent()4.当调用ARouter的withString()等方法它的内部会调用intent.putExtra(String name, String value)存放传递参数。5.调用navigation()方法，它的内部会调用startActivity(intent)进行跳转，这样便可以实现两个相互没有依赖的module顺利的启动对方的Activity了。ARoute的基本思想是这样，当然了ARoute还做了其他很多处理，例如@Interceptor的AOP，@Autowired的依赖注入等，不详细赘述。调用组件某个类某个方法这里参考ARoute的README文档：通过依赖注入解耦:服务管理(一) 暴露服务12345678910111213141516171819// 声明接口,其他组件通过接口来调用服务public interface HelloService extends IProvider &#123; String sayHello(String name);&#125;// 实现接口@Route(path = &quot;/service/hello&quot;, name = &quot;测试服务&quot;)public class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return &quot;hello, &quot; + name; &#125; @Override public void init(Context context) &#123; &#125;&#125;通过依赖注入解耦:服务管理(二) 发现服务12345678910111213141516171819202122232425262728public class Test &#123; @Autowired HelloService helloService; @Autowired(name = &quot;/service/hello&quot;) HelloService helloService2; HelloService helloService3; HelloService helloService4; public Test() &#123; ARouter.getInstance().inject(this); &#125; public void testService() &#123; // 1. (推荐)使用依赖注入的方式发现服务,通过注解标注字段,即可使用，无需主动获取 // Autowired注解中标注name之后，将会使用byName的方式注入对应的字段，不设置name属性，会默认使用byType的方式发现服务(当同一接口有多个实现的时候，必须使用byName的方式发现服务) helloService.sayHello(&quot;Vergil&quot;); helloService2.sayHello(&quot;Vergil&quot;); // 2. 使用依赖查找的方式发现服务，主动去发现服务并使用，下面两种方式分别是byName和byType helloService3 = ARouter.getInstance().navigation(HelloService.class); helloService4 = (HelloService) ARouter.getInstance().build(&quot;/service/hello&quot;).navigation(); helloService3.sayHello(&quot;Vergil&quot;); helloService4.sayHello(&quot;Vergil&quot;); &#125;&#125;事件通知：第三个场景可使用Android的本地广播或者EventBus：https://github.com/greenrobot/EventBus定义事件：1public static class MessageEvent &#123; /* Additional fields if needed */ &#125;事件响应：12@Subscribe(threadMode = ThreadMode.MAIN) public void onMessageEvent(MessageEvent event) &#123;/* Do something */&#125;;注册EventBus：1234567891011@Overridepublic void onStart() &#123; super.onStart(); EventBus.getDefault().register(this);&#125;@Overridepublic void onStop() &#123; super.onStop(); EventBus.getDefault().unregister(this);&#125;发送事件：1EventBus.getDefault().post(new MessageEvent());]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理和注解处理接口Token问题]]></title>
    <url>%2Farchives%2Fcdd0265b.html</url>
    <content type="text"><![CDATA[背景目前在做SDK时，网络层使用的框架是OkHttp + Retrofit，需要对外提供API方式的网络接口调用。一般来说，后台都会有接口校验设计，需要在请求头包含部分加密参数进行验证。我们的项目也是这样处理，外放的接口需要先调用登录接口获取Token，根据Token在请求头进行组合形成鉴权，才能成功通过后台的校验进行使用。这时候想，如果每个接口都需要提前先获取Token，工作量非常大，于是想到了类似Java的AOP的面向切面处理方式，使用动态代理灵活在接口方法前插入获取Token逻辑。而部分接口例如，获取验证码、登录相关的，并不需要Token，因此再自定义一个注解用于区别。动态代理要理解动态代理首先要理解代理，代理：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。代理有什么用呢？举个例子，上大学偶尔舍友会不想上他自己的课，于是让我去代签名，此时我就成为了这个舍友的代理，替他去上课。一般来说，我们使用聚合方式让代理类持有一个被代理类对象，即可实现代理，而此种方式一般称为静态代理。在项目中我们有一个Repository实现了具体的网络接口请求，里面有许多接口方法，如下所示：123456public class Repository implements IRepository &#123; void method1() &#123;...&#125; void method2() &#123;...&#125; void method3() &#123;...&#125; ... &#125;目前我们想要有一个Repository的Proxy类，在每个接口前加入获取Token的逻辑，如果用静态代理来做，如下：12345678910111213141516171819public class RepositoryProxy implements IRepository &#123; IRepository repository; void method1() &#123; getToken(); repository.method1(); &#125; void method2() &#123; getToken(); repository.method2(); &#125; void method3() &#123; getToken(); repository.method3(); &#125; ... void getToken() &#123;...&#125;&#125;可以看到每个接口前都需要调用getToken，同样的逻辑需要反复实现，虽然效果达到了，但是由此写了很多重复的代码，因此静态代理也不适用于我们的需求。于是使用动态代理来实现，这样就达到了预期的效果，如下：1234567891011121314public class RepositoryInvocationHandler implements InvocationHandler &#123; IRepository repository; @Override public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable &#123; if(如果需要Token) &#123; getToken(); &#125; return method.invoke(repository, args); &#125; void getToken() &#123;...&#125;&#125;具体是实现InvocationHandler接口，覆写invoke方法，method.invoke(repository, args)即等价于调用IRepository的网络请求接口，在此方法前可以插入自定义逻辑。在原本需要调用Repository的地方生成动态代理方式，如下：123Repository repository = new Repository();RepositoryInvocationHandler repositoryInvocationHandler = new RepositoryInvocationHandler(repository);proxy = (IRepository) (Proxy.newProxyInstance(IRepository.class.getClassLoader(), new Class[]&#123;IRepository.class&#125;, repositoryInvocationHandler));注解注解（也被成为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。 ———摘自《Thinking in Java》简单来说注解的作用就是将我们的需要的数据储存起来，在以后的某一个时刻（可能是编译时，也可能是运行时）去调用它。在我们的项目中，针对部分接口不需要Token的，处理逻辑不同，于是通过自定义注解实现，如下：1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface NeedToken &#123;&#125;在Repository中，对需要获取Token的方法前加@NeedToken即可。最后修改InvocationHandler的逻辑，如下：1234567891011121314151617public class RepositoryInvocationHandler implements InvocationHandler &#123; IRepository repository; @Override public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable &#123; // 如果带NeedToken有注解，先判断是否获取了Token，否则需要获取，再调用API方法 NeedToken isNeedToken = method.getAnnotation(NeedToken.class); if(isNeedToken != null) &#123; getToken(); &#125; // 否则直接调用方法即可 return method.invoke(repository, args); &#125; void getToken() &#123;...&#125;&#125;另外，由于getToken一般也为一个接口方法，需要异步回调获取Token，需注意RepositoryInvocationHandler类不能写成单例，应该每个接口方法对应一个proxy，对应一个获取Token回调，否则会造成冲突。Done.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SlidingCheckLayout滑动选择布局实现]]></title>
    <url>%2Farchives%2F2720d64c.html</url>
    <content type="text"><![CDATA[背景项目需求，要求在选择本地图片时，可对图片进行滑动选择。类似小米图库或者图库，现在很多手机系统内置图库都自带了这个功能。最后经过调研，使用自定义View解决。SlidingCheckLayout滑动选择布局，用于嵌套RecyclerView实现滑动选择功能。效果如图所示：最后将代码整理了一下，并上传到Jitpack。源码https://github.com/huangyu/SlidingCheckLayout引用方式在根目录：123456allprojects &#123; repositories &#123; ... maven &#123; url &apos;https://jitpack.io&apos; &#125; &#125;&#125;添加依赖：1234dependencies &#123; ... implementation &apos;com.github.huangyu0:SlidingCheckLayout:x.x.x&apos;&#125;使用方法在layout的xml中，在RecyclerView外层嵌套SlidingCheckLayout作为唯一子节点。在App中实现SlidingCheckLayout.OnSlidingCheckListener接口即可，具体可参考Demo工程。原理通过onInterceptTouchEvent方法拦截滑动请求，找到起始点坐标。12345678// 计算起始点坐标View child = targetRlv.findChildViewUnder(ev.getX(), ev.getY());if (child != null) &#123; int position = targetRlv.getChildAdapterPosition(child); if (position != RecyclerView.*NO_POSITION*&amp;&amp; startPos != position) &#123; startPos = position; &#125;&#125;RecycleView的findChildViewUnder()方法，可以十分方便返回指定位置的childView。判断是否处于滑动状态，xTouchSlop和yTouchSlop为横向和纵向两个阈值。12345float xDiff = Math.*abs*(ev.getX() - startX);float yDiff = Math.*abs*(ev.getY() - startY);if (yDiff &lt; yTouchSlop &amp;&amp; xDiff &gt; xTouchSlop) &#123; isSliding = true;&#125;为了和RecycleView的Item点击事件不冲突，通过自定义一个判断标记isSliding，返回是否拦截滑动请求，即是否进行了滑动选择。通过onTouchEvent处理具体的拦截逻辑。12345678910111213141516171819202122@Overridepublic boolean onTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.*ACTION_DOWN*: break; case MotionEvent.*ACTION_MOVE*: if (!inTopSpot &amp;&amp; !inBottomSpot) &#123; // 处理滑动事件 updateSelectedRange(targetRlv, ev); &#125; // 在顶部或者底部触发自动滑动 processAutoScroll(ev); break; case MotionEvent.*ACTION_UP*: resetParams(); stopAutoScroll(); performClick(); return false; &#125; return isSliding;&#125;既然是滑动，处理事件肯定是在ACTION_MOVE里。这里的inTopSpot和inBottomSpot两个标记用于计算是否滑动到顶部或者底部，用于滑动到顶部或者底部时，使用Scroller进行自动滚动。具体实现在processAutoScroll方法。updateSelectedRange则处理滑动选择。12345678910private void updateSelectedRange(RecyclerView rv, float x, float y) &#123; View child = rv.findChildViewUnder(x, y); if (child != null) &#123; int position = rv.getChildAdapterPosition(child); if (position != RecyclerView.*NO_POSITION*&amp;&amp; endPos != position) &#123; endPos = position; notifySelectRangeChange(); &#125; &#125;&#125;这里同样用findChildViewUnder方法记录结束标志，现在获取到了起始点和结束点。12345678910111213141516171819202122232425262728293031private void notifySelectRangeChange() &#123; if (onSlidingCheckListener == null) &#123; return; &#125; if (startPos == RecyclerView.*NO_POSITION*|| endPos == RecyclerView.*NO_POSITION*) &#123; return; &#125; int newStart, newEnd; newStart = Math.*min*(startPos, endPos); newEnd = Math.*max*(startPos, endPos); if (lastStartPos == RecyclerView.*NO_POSITION*|| lastEndPos == RecyclerView.*NO_POSITION*) &#123; onSlidingCheckListener.onSlidingCheckPos(newStart, newEnd); &#125; else &#123; if (newStart &gt; lastStartPos) &#123; onSlidingCheckListener.onSlidingCheckPos(lastStartPos, newStart - 1); &#125; else if (newStart &lt; lastStartPos) &#123; onSlidingCheckListener.onSlidingCheckPos(newStart, lastStartPos - 1); &#125; if (newEnd &gt; lastEndPos) &#123; onSlidingCheckListener.onSlidingCheckPos(lastEndPos + 1, newEnd); &#125; else if (newEnd &lt; lastEndPos) &#123; onSlidingCheckListener.onSlidingCheckPos(newEnd + 1, lastEndPos); &#125; &#125; lastStartPos = newStart; lastEndPos = newEnd;&#125;notifySelectRangeChange为核心处理逻辑，通过当前滑动的起始点和终点计算中间滑动的范围并回调给调用方。这里自定义了一个回调接口类：123public interface OnSlidingCheckListener &#123; void onSlidingCheckPos(int startPos, int endPos);&#125;最后外部使用回调对起始点至终点部分进行选择处理。123456789101112131415scl.setOnSlidingCheckListener(new SlidingCheckLayout.OnSlidingCheckListener() &#123; @Override public void onSlidingCheckPos(int startPos, int endPos) &#123; RecyclerView recyclerView = (RecyclerView) scl.getChildAt(0); for (int I = startPos; I &lt;= endPos; I++) &#123; View current = recyclerView.getLayoutManager().findViewByPosition(i); if (current != null) &#123; View currentLayout = current.findViewById(R.id.*rl_root*); if (currentLayout != null) &#123; currentLayout.performClick(); &#125; &#125; &#125; &#125;&#125;);Done.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法汇总]]></title>
    <url>%2Farchives%2F3c50d03d.html</url>
    <content type="text"><![CDATA[Markdown语法汇总标题使用#，可表示1-6级标题。一级标题二级标题三级标题四级标题五级标题六级标题无序列表使用·、+、或-标记无序列表。注意：标记后面最少有一个_空格_或制表符。若不在引用区块中，必须和前方段落之间存在空行。无序列表1无序列表2无序列表3有序列表有序列表的标记方式是将上述的符号换成数字,并辅以.。有序列表1有序列表2有序列表3强调在强调内容两侧分别加上*或者_。斜体_斜体加粗加粗段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用。引用嵌套引用代码代码区块的建立是在每行加上4个空格或者一个制表符。void main() { printf(&quot;Hello, Markdown.&quot;); } 或者使用上下三个`包裹。1234void main()&#123; printf(&quot;Hello, Markdown.&quot;);&#125;分割线分割线最常使用就是三个或以上*，还可以使用-和_。链接，[]内为描述信息，()为链接地址。huangyu的随记随想图片添加图片的形式和链接相似，只需在链接的基础上前方加一个!。转义\相当于反转义作用。使符号成为普通符号。标记`符号起到标记作用。标记表格在 Markdown 中，可以制作表格。1234First Header | Second Header | Third Header------------ | ------------- | ------------Content Cell | Content Cell | Content CellContent Cell | Content Cell | Content CellFirst HeaderSecond HeaderThird HeaderContent CellContent CellContent CellContent CellContent CellContent Cell或者也可以让表格两边内容对齐，中间内容居中。1234First Header | Second Header | Third Header:----------- | :-----------: | -----------:Left | Center | RightLeft | Center | RightFirst HeaderSecond HeaderThird HeaderLeftCenterRightLeftCenterRight]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
