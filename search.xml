<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[kotlin设计模式]]></title>
    <url>%2Farchives%2F5ff9cb15.html</url>
    <content type="text"><![CDATA[kotlin设计模式简单工厂定义一个工厂类，它可以根据参数的不同返回不同类的实例。SimpleFactory.kt工厂方法工厂方法把创建对象的过程抽象为接口，由工厂的子类决定对象的创建。FactoryMethod.kt抽象工厂工厂方法针对一种产品，而抽象工厂是针对一系列产品，为每种产品定义一个工厂方法，工厂子类负责创建该系列的多种产品。AbstractFactory.kt单例单例模式在Kotlin下直接使用object就行了。Singleton.kt建造者建造者模式是为了构建复杂对象的，一般情况下，Kotlin中使用标准的apply函数就可以。Builder.kt原型原型模式是以一个对象为原型，创建出一个新的对象，在Kotlin下很容易实现，用data class的copy就可以。Prototype.kt适配器适配器模式是把一个不兼容的接口转化为另一个类可以使用的接口。Adapter.kt桥接桥接模式可以分离某个类存在两个独立变化的纬度，把多层继承结构改为两个独立的继承结构，在两个抽象层中有一个抽象关联。Bridge.kt组合组合模式是对树形结构的处理，让调用者忽视单个对象和组合结构的差异。Composite.kt装饰装饰模式可以给一个对象添加额外的行为，在Kotlin下可以用扩展函数实现。Decorator.kt外观外观模式是为一个复杂的子系统提供一个简化的统一接口。Facade.kt享元享元模式以共享的方式高效地支持大量细粒度对象的重用，享元对象能做到共享的关键是区分了可共享内部状态和不可共享外部状态。FlyWeight.kt代理代理模式是使用一个代理对象来访问目标对象的行为。Proxy.kt责任链职责链模式通过建立一条链来组织请求的处理者，请求将沿着链进行传递。ChainReponsibility.kt命令命令模式是将请求封装为命令对象，解耦请求发送者与接收者，对请求排队或者记录请求日志，以及支持可撤销的操作。Command.kt解释器模式解释器模式是定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。Interpreter.kt迭代器迭代器模式提供一种不暴露底层实现情况下的遍历聚合对象中的元素的一种方式。Iterator.kt中介者中介者模式用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。Mediator.kt备忘录备忘录模式是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。Memento.kt观察者观察者模式是一个对象状态发生变化后，可以立即通知已订阅的另一个对象。Observer.kt状态模式状态模式将一个对象在不同状态下的不同行为封装在一个个状态类中，通过设置不同的状态可以让对象拥有不同的行为。State.kt策略模式策略模式用于算法的自由切换和扩展，分离算法的定义与实现，在 Kotlin 中可以使用高阶函数作为算法的抽象。Strategy.kt模版方法模板方法模式提供了一个模板方法来定义算法框架，而某些具体步骤的实现可以在其子类中完成，Kotlin 中使用高阶函数可以避免继承的方式。Template.kt访问者访问者模式提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。Visitor.kt]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-flow分支策略]]></title>
    <url>%2Farchives%2Feeda3694.html</url>
    <content type="text"><![CDATA[git-flow分支管理策略是非常流行的，实际项目的版本管理中可以借鉴其思想。https://nvie.com/posts/a-successful-git-branching-model/git-flow将分支分为以下几种类型：类型来源去向说明master主分支releasedevelopdevelop和master预发布分支developrelease和master开发分支featuredevelopdevelop功能分支hotfixmasterdevelop和master紧急修复分支 master主分支，永远是可用的、稳定的、可直接发布的版本；不能直接在该分支上开发；合并release稳定版本后打Tag确定版本。release预发布分支，在develop分支上创建，用于发布测试版本；修改好bug并确定稳定之后合并到develop和master分支，然后发布master分支；上线后可删除。创建并切换到release分支：1$ git checkout -b release-1.2 develop修复bug完毕提交：1$ git commit -a -m &quot;release 1.2&quot;release合并到master分支：12$ git checkout master$ git merge --no-ff release-1.2master分支打tag：1$ git tag -a 1.2删除release分支：1$ git branch -d release-1.2develop开发主分支，代码永远是最新；所有新功能以这个分支来创建自己的feature分支，该分支只做合并操作，不能直接在该分支上开发。feature功能分支，在develop上创建分支，以自己开发功能模块命名；功能测试正常后合并到develop分支，然后可删除。创建并切换到feature分支：1$ git checkout -b myfeature developfeature合并到develop分支：12$ git checkout develop$ git merge --no-ff myfeature开发完毕删除分支并推送：12$ git branch -d myfeature$ git push origin develophotfix紧急修复分支，项目上线之后可以会遇到Bug需要紧急修复，从master分支上创建；修复完成后合并到develop和master分支，然后可进行删除。创建并切换到hotfix分支：1$ git checkout -b hotfix-1.2.1 master修复完毕提交：1$ git commit -a -m &quot;hotfiex 1.2.1&quot;hotfix合并到master分支：12$ git checkout master$ git merge --no-ff hotfix-1.2.1master分支打tag：1$ git tag -a 1.2.1删除hotfix分支：1$ git branch -d hotfix-1.2.1除了master和develop分支是一直持续以外，其余分支工作完毕后可进行删除。分支命名规范分支命名规范建议如下：origin/类型/版本/描述例如：origin/masterorigin/release/1.0.0origin/release/1.0.1-bugfixorigin/developorigin/feature/1.0.1/AAAorigin/feature/1.0.1/BBBorigin/hotfix/1.0.0]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Picasso源码分析]]></title>
    <url>%2Farchives%2F38a31505.html</url>
    <content type="text"><![CDATA[Picasso介绍https://github.com/square/picassoPicasso是Android开发中常用的几大图片加载库之一，除此之外常用的还有UIL、Glide、Fresco等。目前UIL作者已经不再维护，Glide源码比较复杂，Fresco涉及c语言层面。相比之下Picasso写得比较简洁、规范，更好入手分析。通过分析Picasso源码来对Android的图片加载有更深入的理解。目前最新版本为2.71828（奇葩的版本号），本文基于此分析。最新的使用方式为：1PicassoProvider.get().load(&quot;url&quot;).into(imageview)下面就根据这个调用流程来分析其源码。图示Picasso的get方法此前Picasso包括Glide的调用方式都需要通过with(context)方法来传入context，最新版本通过一个get方法即可实现。项目中单独提供一个picasso-provider库工程实现此方法。123456789101112131415161718192021public final class PicassoProvider &#123; @SuppressLint(&quot;StaticFieldLeak&quot;) private static volatile Picasso instance; @Initializer public static Picasso get() &#123; if (instance == null) &#123; synchronized (PicassoProvider.class) &#123; if (instance == null) &#123; Context autoContext = PicassoContentProvider.context; if (autoContext == null) &#123; throw new NullPointerException(&quot;context == null&quot;); &#125; instance = new Picasso.Builder(autoContext).build(); &#125; &#125; &#125; return instance; &#125; ...&#125;此处使用双重校验锁来实现Picasso类单例。context的获取通过PicassoContentProvider类实现：12345678910public final class PicassoContentProvider extends ContentProvider &#123; @SuppressLint(&quot;StaticFieldLeak&quot;) @Nullable static Context context; @Override public boolean onCreate() &#123; context = getContext(); return true; &#125; ...&#125;此类在AndroidManifest中注册，因此在App启动的时候，系统就会自动回调PicassoContentProvider 的onCreate方法，因此也就自动获取到了Context。Picasso的创建Picasso通过Builder模式创建实例，通过以下这行代码获取实例。1instance = new Picasso.Builder(autoContext).build();Builder类构造函数：1234567891011121314151617181920Builder(Picasso picasso) &#123; context = picasso.context; // OkHttp的Call工厂，使用OkHttp处理网络请求 callFactory = picasso.callFactory; // 请求分发服务 service = picasso.dispatcher.service; // 缓存处理类 cache = picasso.cache; // 回调监听 listener = picasso.listener; // 变换器，List&lt;RequestTransformers&gt; requestTransformers.addAll(picasso.requestTransformers); // 计算请求处理器数量，List&lt;RequestHandler&gt;后续分析 int numRequestHandlers = picasso.requestHandlers.size(); requestHandlers.addAll(picasso.requestHandlers.subList(2, numRequestHandlers - 6)); defaultBitmapConfig = picasso.defaultBitmapConfig; indicatorsEnabled = picasso.indicatorsEnabled; loggingEnabled = picasso.loggingEnabled;&#125;build方法：1234567891011121314151617181920212223242526272829public Picasso build() &#123; Context context = this.context; // 配置OkHttp3 Cache和Factory okhttp3.Cache unsharedCache = null; if (callFactory == null) &#123; File cacheDir = createDefaultCacheDir(context); long maxSize = calculateDiskCacheSize(cacheDir); unsharedCache = new okhttp3.Cache(cacheDir, maxSize); callFactory = new OkHttpClient.Builder() .cache(unsharedCache) .build(); &#125; // 配置Picasso的Cache，使用LRU最近最少使用方式缓存 if (cache == null) &#123; cache = new PlatformLruCache(Utils.calculateMemoryCacheSize(context)); &#125; // 默认使用PicassoExecutorService线程池，用于后续Bitmap的获取 if (service == null) &#123; service = new PicassoExecutorService(); &#125; // 统计信息类，统计缓存命中，图片下载数等数据 Stats stats = new Stats(cache); // 请求分发，HANDLER在主线程处理事件，用于将获取到的Bitmap显示 Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, cache, stats); // 返回Picasso实例 return new Picasso(context, dispatcher, callFactory, unsharedCache, cache, listener, requestTransformers, requestHandlers, stats, defaultBitmapConfig, indicatorsEnabled, loggingEnabled);&#125;Picasso构造函数：1234567891011121314151617181920212223242526272829303132333435363738394041Picasso(...) &#123; ... // Picasso内置一个List&lt;RequestTransformer&gt;用于处理请求变换 this.requestTransformers = Collections.unmodifiableList(new ArrayList&lt;&gt;( ... // Picasso 默认包含8个内置 RequestHandler 分别用来处理8种不同类型的请求 int builtInHandlers = 8; ... // 可添加自定义的RequestHandler List&lt;RequestHandler&gt; allRequestHandlers = new ArrayList&lt;&gt;(builtInHandlers + extraCount); // ResourceRequestHandler，用于处理.xml资源文件 allRequestHandlers.add(ResourceDrawableRequestHandler.create(context)); // ResourceRequestHandler，用于处理Res资源文件 allRequestHandlers.add(new ResourceRequestHandler(context)); allRequestHandlers.addAll(extraRequestHandlers); // ContactsPhotoRequestHandler，用于处理手机联系人图片 allRequestHandlers.add(new ContactsPhotoRequestHandler(context)); // MediaStoreRequestHandler，用于处理content://media/开头的URI allRequestHandlers.add(new MediaStoreRequestHandler(context)); // ContentStreamRequestHandler，用于处理scheme为content的URI allRequestHandlers.add(new ContentStreamRequestHandler(context)); // AssetRequestHandler，用于处理file:///android_asset/开头的URI allRequestHandlers.add(new AssetRequestHandler(context)); // FileRequestHandler，用于处理scheme为file的URI allRequestHandlers.add(new FileRequestHandler(context)); // NetworkRequestHandler，用于处理http或https图片url allRequestHandlers.add(new NetworkRequestHandler(callFactory, stats)); // 返回一个不能进行修改操作的List实例，防止requestHandlers被修改 requestHandlers = Collections.unmodifiableList(allRequestHandlers); ... &#125;Picasso创建分析完毕。Picasso的load方法load方法对应不同的重载方法：包括int、String、Object、Uri等，以Uri为例：123public RequestCreator load(@Nullable Uri uri) &#123; return new RequestCreator(this, uri, 0);&#125;最终创建并返回一个RequestCreator实例。1234567RequestCreator(Picasso picasso, @Nullable Uri uri, int resourceId) &#123; ... // 持有Picasso实例 this.picasso = picasso; // 通过Builder创建Request this.data = new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);&#125;RequestCreator核心就是创建Request.Builder，即data实例。RequestCreator创建完成后，内部还包含placeholder、error、fit等方法，可继续链式调用，这里主要分析主流程，不详细赘述。RequestCreator的into方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void into(@NonNull ImageView target, @Nullable Callback callback) &#123; ... // data即前面的Request.Builder实例 // 如果data中没有图片(例如传入的path为null) // 直接对该target取消请求，并设置占位图如果有设置placeholder if (!data.hasImage()) &#123; picasso.cancelRequest(target); if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; return; &#125; ... // 创建请求 Request request = createRequest(started); // 如果当前的memoryPolicy允许从缓存中读取图片 // 从Cache中获取 requestKey 对应的Bitmap，如果该Bitmap存在 // 则取消当前请求，直接为target设置该Bitmap if (shouldReadFromMemoryCache(request.memoryPolicy)) &#123; Bitmap bitmap = picasso.quickMemoryCacheCheck(request.key); if (bitmap != null) &#123; picasso.cancelRequest(target); RequestHandler.Result result = new RequestHandler.Result(bitmap, MEMORY); setResult(target, picasso.context, result, noFade, picasso.indicatorsEnabled); if (picasso.loggingEnabled) &#123; log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), &quot;from &quot; + MEMORY); &#125; if (callback != null) &#123; callback.onSuccess(); &#125; return; &#125; &#125; // 前面缓存中没有查找到图片，从这里开始请求 // 先设置 placeholder 如果有配置的话 if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; // 创建ImageViewAction，主要将获取的Bitmap加载到ImageView中 Target&lt;ImageView&gt; wrapper = new Target&lt;&gt;(target, errorResId, errorDrawable, noFade); Action action = new ImageViewAction(picasso, wrapper, request, callback); // 加入异步请求队列处理 picasso.enqueueAndSubmit(action);&#125;createRequest创建Request实例。12345678910111213141516171819202122232425262728private Request createRequest(long started) &#123; int id = nextId.getAndIncrement(); // 创建Request Request request = data.build(); request.id = id; request.started = started; boolean loggingEnabled = picasso.loggingEnabled; if (loggingEnabled) &#123; log(OWNER_MAIN, VERB_CREATED, request.plainId(), request.toString()); &#125; // 如果有RequestTransformer，则逐一处理 Request transformed = picasso.transformRequest(request); if (transformed != request) &#123; // If the request was changed, copy over the id and timestamp from the original. transformed.id = id; transformed.started = started; if (loggingEnabled) &#123; log(OWNER_MAIN, VERB_CHANGED, transformed.logId(), &quot;into &quot; + transformed); &#125; &#125; // 返回Request return transformed; &#125;上述主要分析了PicassoProvider.get().load(“url”).into(imageview)整体流程。Dispatcher处理请求流程前面分析into方法的最后，图片以Action的形式加入Picasso请求：12345picasso.enqueueAndSubmit(action)void submit(Action action) &#123; dispatcher.dispatchSubmit(action);&#125;请求加入Dispatcher中，然后放到Handler进行处理。123void dispatchSubmit(Action action) &#123; handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));&#125;Dispatcher核心是DispatcherThread、DispatcherHandler、PicassoExecutorService。DispatcherThread是一个HandlerThread，HandlerThread有自己的内部Looper对象，将Message发送给DispatcherHandler在handleMessage进行处理。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private static class DispatcherHandler extends Handler &#123; private final Dispatcher dispatcher; DispatcherHandler(Looper looper, Dispatcher dispatcher) &#123; super(looper); this.dispatcher = dispatcher; &#125; @Override public void handleMessage(final Message msg) &#123; switch (msg.what) &#123; // 提交请求 case REQUEST_SUBMIT: &#123; Action action = (Action) msg.obj; dispatcher.performSubmit(action); break; &#125; // 取消请求 case REQUEST_CANCEL: &#123; Action action = (Action) msg.obj; dispatcher.performCancel(action); break; &#125; // 暂停请求 case TAG_PAUSE: &#123; Object tag = msg.obj; dispatcher.performPauseTag(tag); break; &#125; // 恢复请求 case TAG_RESUME: &#123; Object tag = msg.obj; dispatcher.performResumeTag(tag); break; &#125; // hunter完成 case HUNTER_COMPLETE: &#123; BitmapHunter hunter = (BitmapHunter) msg.obj; dispatcher.performComplete(hunter); break; &#125; // hunter重试 case HUNTER_RETRY: &#123; BitmapHunter hunter = (BitmapHunter) msg.obj; dispatcher.performRetry(hunter); break; &#125; // hunter解码失败 case HUNTER_DECODE_FAILED: &#123; BitmapHunter hunter = (BitmapHunter) msg.obj; dispatcher.performError(hunter); break; &#125; // 网络状态变更 case NETWORK_STATE_CHANGE: &#123; NetworkInfo info = (NetworkInfo) msg.obj; dispatcher.performNetworkStateChange(info); break; &#125; // 飞行模式变更 case AIRPLANE_MODE_CHANGE: &#123; dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON); break; &#125; default: Picasso.HANDLER.post(new Runnable() &#123; @Override public void run() &#123; throw new AssertionError(&quot;Unknown handler message received: &quot; + msg.what); &#125; &#125;); &#125; &#125; &#125;再来看看Dispathcer的perormSubmit方法。12345678910111213void performSubmit(Action action, boolean dismissFailed) &#123; // 前面是做一些必要的判断处理 ... // 获取Action的Hunter hunter = forRequest(action.getPicasso(), this, cache, stats, action); // 将Hunter加入线程池 hunter.future = service.submit(hunter); // 存入hunterMap中 hunterMap.put(action.getKey(), hunter); ...&#125;service即PicassoExecutorService，是Picasso实现基于优先级队列PriorityBlockingQueue的线程池，继承于ThreadPoolExecutor，内部有一个FutureTask实现类PicassoFutureTask。PicassoFutureTask通过compareTo方法比较请求的优先级，具体实现在其内部持有的BitmapHunter内部。BitmapHunter是Runnable子类，具体作用就是“狩猎”bitmap，返回一个持有bitmap的Result。service.submit(hunter)即是将FutureTask提交到线程池处理，返回一个Future，此处之所以用FutureTask，是用于监听hunter是否执行完毕且可以cancel执行。BitmapHunter其核心是run里的hunt方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Result hunt() throws IOException &#123; // 缓存命中则直接获取Result返回 if (shouldReadFromMemoryCache(data.memoryPolicy)) &#123; Bitmap bitmap = cache.get(key); if (bitmap != null) &#123; stats.dispatchCacheHit(); if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_DECODED, data.logId(), &quot;from cache&quot;); &#125; return new Result(bitmap, MEMORY); &#125; &#125; ... // RequestHandler即最开始提的8种请求处理，根据图片来源的不同进行处理 final CountDownLatch latch = new CountDownLatch(1); try &#123; requestHandler.load(picasso, data, new RequestHandler.Callback() &#123; @Override public void onSuccess(@Nullable Result result) &#123; resultReference.set(result); latch.countDown(); &#125; @Override public void onError(@NonNull Throwable t) &#123; exceptionReference.set(t); latch.countDown(); &#125; &#125;); latch.await(); &#125; catch (InterruptedException ie) &#123; InterruptedIOException interruptedIoException = new InterruptedIOException(); interruptedIoException.initCause(ie); throw interruptedIoException; &#125; ... Result result = resultReference.get(); Bitmap bitmap = result.getBitmap(); if (bitmap != null) &#123; if (picasso.loggingEnabled) &#123; log(OWNER_HUNTER, VERB_DECODED, data.logId()); &#125; // 解码bitmap stats.dispatchBitmapDecoded(bitmap); // 做Transformation变换处理 List&lt;Transformation&gt; transformations = new ArrayList&lt;&gt;(data.transformations.size() + 1); if (data.needsMatrixTransform() || result.getExifRotation() != 0) &#123; transformations.add(new MatrixTransformation(data)); &#125; transformations.addAll(data.transformations); result = applyTransformations(picasso, data, transformations, result); bitmap = result.getBitmap(); if (bitmap != null) &#123; stats.dispatchBitmapTransformed(bitmap); &#125; // 返回Result return result;&#125;run方法再将处理的结果发送回Dispathcer，例如dispatchComplete和dispatchFailed。Dispathcer里还维护了一个主线程Handler，mainThreadHandler，在Picasso类实现传入。前面处理的结果最终会通过一个deliver方法传回mainThreadHandler，通过回调监听返回listener返回给Picasso使用方，即App。至此，Picasso主要流程分析完毕。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android P使用私有API弹出warning]]></title>
    <url>%2Farchives%2F35fd3a81.html</url>
    <content type="text"><![CDATA[最近手头的Mix2s接收到MIUI官方开发版的推送，可以升级为Android P，很开心，然后升级后，部分应用就打不开或者挂了，比如某奇艺（买了VIP看剧都看不了，强烈吐槽）。于是顺手检查了一下公司的应用，发现都能正常启动和使用，但是最近在做SDK的接入Demo，一打开发现弹出了warning对话框：起初以为是targetAPI的问题，升级到28问题依旧，于是Google了一下，发现是从Android P开始，系统会限制非SDK的接口调用，也就是如果App通过反射使用系统隐藏的API，则会弹出提示。具体的细节可参考：https://developer.android.com/about/versions/pie/restrictions-non-sdk-interfaces?hl=zh-cnAndroid P中，将所有API分为以下几类：白名单：SDK的API，正常使用；浅灰名单（light greylist）会在logcat弹出提示：Accessing hidden field Landroid/os/Message;-&gt;flags:I (light greylist, JNI)；深灰名单（dark greylist）则debug版本在会弹出dialog提示框，在release版本会有Toast提示，均提示为”Detected problems with API compatibility”。；黑名单(darklist)则会引发异常。看了logcat日志，项目中许多地方使用到了系统私有API，直接全部修改工作量比较大，于是寻找解决方案。最后发现原因是在SDK 28版本中Activity中的performStart有这个警告，只要在调用performStart前，ActivityThread的mHiddenApiWarningShown变量的值为true，产生这个警告的条件就无法满足。1234567891011121314151617181920212223boolean isAppDebuggable = (mApplication.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0;// This property is set for all non-user builds except final releaseboolean isApiWarningEnabled = SystemProperties.getInt(&quot;ro.art.hiddenapi.warning&quot;, 0) == 1;if (isAppDebuggable || isApiWarningEnabled) &#123; if (!mMainThread.mHiddenApiWarningShown &amp;&amp; VMRuntime.getRuntime().hasUsedHiddenApi()) &#123; // Only show the warning once per process. mMainThread.mHiddenApiWarningShown = true; String appName = getApplicationInfo().loadLabel(getPackageManager()) .toString(); String warning = &quot;Detected problems with API compatibility\n&quot; + &quot;(visit g.co/dev/appcompat for more info)&quot;; if (isAppDebuggable) &#123; new AlertDialog.Builder(this) .setTitle(appName) .setMessage(warning) .setPositiveButton(android.R.string.ok, null) .setCancelable(false) .show(); &#125; else &#123; Toast.makeText(this, appName + &quot;\n&quot; + warning, Toast.LENGTH_LONG).show(); &#125; &#125;&#125;具体是在Application OnCreate加入以下代码：（通过反射私有变量来解决私有API的warning，也是有趣）1234567891011try &#123; Class&lt;?&gt; cls = Class.forName(&quot;android.app.ActivityThread&quot;); Method declaredMethod = cls.getDeclaredMethod(&quot;currentActivityThread&quot;); declaredMethod.setAccessible(true); Object activityThread = declaredMethod.invoke(null); Field mHiddenApiWarningShown = cls.getDeclaredField(&quot;mHiddenApiWarningShown&quot;); mHiddenApiWarningShown.setAccessible(true); mHiddenApiWarningShown.setBoolean(activityThread, true);&#125; catch (Exception e) &#123; e.printStackTrace();&#125;最终warning框不再弹出，但是logcat依旧，在Logcat中看到，修改mHiddenApiWarningShown本身就是dark greylist，估计后续该办法会给官方禁用。最好的解决方式是根据logcat的warning提示，对使用darklist的地方必须进行修改，尽量避免使用dark greylist方法。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android组件化初探]]></title>
    <url>%2Farchives%2F22258b7f.html</url>
    <content type="text"><![CDATA[组件化的优势：代码架构更加清晰，降低项目的维护难度；组件模式下可以加快编译速度，提高开发效率；项目比较大的情况下，多团队独立开发不同模块，互不影响；利于向插件化变更。架构：App壳工程与具体的业务无关，作为门面封装入口。Module实现具体的模块功能，Module之间解耦合，组件可独立于App壳工程单独运行。Common用于存放公用资源，例如res、工具类，公用第三方library等，各Module依赖于Common。Demohttps://github.com/huangyu/ComponentDemo组件模式和集成模式gradle.properties中配置isModule=false，通过if(isModule.toBoolean())判断是否是组件模式。注意：每次更改“isModule”的值后，需要点击 “Sync Project” 按钮。在组件的build.gradle中，区分当前Module是组件模式还是集成模式。12345if (isModule.toBoolean()) &#123; apply plugin: &apos;com.android.application&apos;&#125; else &#123; apply plugin: &apos;com.android.library&apos;&#125;AndroidManifest和Application文件问题12345678910111213sourceSets &#123; main &#123; if (isModule.toBoolean()) &#123; manifest.srcFile &apos;src/main/module/AndroidManifest.xml&apos; &#125; else &#123; manifest.srcFile &apos;src/main/AndroidManifest.xml&apos; // 集成开发模式下排除debug文件夹中的所有Java文件 java &#123; exclude &apos;library/**&apos; &#125; &#125; &#125;&#125;每个使用两份AndroidManifest.xml：一个用于集成模式，即定义内部组件、权限等信息，不包含Application信息和启动类信息。一个用于组件模式，包含Application信息和启动类信息，可用于组件单独运行。组件的Application放置于java/library目录，基于Common库的BaseApplication，集成模式打包不加入。业务组件自己的 Application 可以在组件开发模式下初始化一些数据，Common 组件初始化公用数据，例如全局Context等。资源冲突资源重名，比如App壳工程有资源和Module重名，则会覆盖Module同名资源，造成显示不准确。利用resourcePrefix “prefix_”在资源名加前缀可避免重名问题。设置了resourcePrefix值后，所有的资源名必须以指定的字符串做前缀，否则会报错。resourcePrefix这个值只能限定xml里面的资源，并不能限定图片资源，所有图片资源仍然需要手动去修改资源名。library 重复依赖不同Module都依赖了Common，会不会导致 library 重复依赖呢？实际上在 release 构建 APP 的过程中 Gradle 会自动将重复的 aar 包排除，因此不存在此问题。混淆问题一般对于开源的第三方库，没有加入混淆的必要；对于部分闭源的项目，如果需要可用consumerProguardFiles对核心代码和算法进行混淆。我们自己的项目使用，Module间没有混淆代码的必要（不同开发小组没有必要相互隐藏代码实现吧），统一在App里混淆即可。组件通信组件间通信包括三个场景：（1）UI 跳转；（2）调用组件某个类的某个方法； （3）事件通知前两个场景建议使用强大的路由库：https://github.com/alibaba/ARouterUI跳转使用方式：通过@Route定义Activity或者Fragment的路径使用ARouter.getInstance().build(“url”).navigation()进行跳转如果模块没有集成进来，想要跳转到这个页面的时候，不会崩溃，设置debug模式的时候会出现找不到的提示，而点击属于这个模块的功能的时候则不会有反应。在没有ARouter或者其他类似的路由库的时候，我们想从组件间进行Activity跳转，怎么处理？答案就是：反射！只要知道对应要跳转的Activity包名全路径，反射即可获取对应的Activity类，即可进行跳转。那么我们可以构造一个全局的Map，Map的key是路径，value是具体的类信息，即可实现全局的管理。另外，需要了解APT：APT技术可以让我们通过自定义注解动态生成编译后的class代码，ARoute里使用了APT去生成注解处理文件。ARouter背后的原理是怎么样的呢？实际上它的核心思想跟上面讲解的是一样的。1.在Activity定义@Route注解，会在编译时期通过APT生成一些存储path和activityClass映射关系的类文件。2.ARoute.init()在app进程启动的时候会拿到这些类文件，把保存这些映射关系的数据保存在map里。3.通过build()方法传入要到达页面的路由地址，ARouter会通过它自己存储的路由表找到路由地址对应的Activity.class(activity.class = map.get(path))，然后new Intent()4.当调用ARouter的withString()等方法它的内部会调用intent.putExtra(String name, String value)存放传递参数。5.调用navigation()方法，它的内部会调用startActivity(intent)进行跳转，这样便可以实现两个相互没有依赖的module顺利的启动对方的Activity了。ARoute的基本思想是这样，当然了ARoute还做了其他很多处理，例如@Interceptor的AOP，@Autowired的依赖注入等，不详细赘述。调用组件某个类某个方法这里参考ARoute的README文档：通过依赖注入解耦:服务管理(一) 暴露服务12345678910111213141516171819// 声明接口,其他组件通过接口来调用服务public interface HelloService extends IProvider &#123; String sayHello(String name);&#125;// 实现接口@Route(path = &quot;/service/hello&quot;, name = &quot;测试服务&quot;)public class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return &quot;hello, &quot; + name; &#125; @Override public void init(Context context) &#123; &#125;&#125;通过依赖注入解耦:服务管理(二) 发现服务12345678910111213141516171819202122232425262728public class Test &#123; @Autowired HelloService helloService; @Autowired(name = &quot;/service/hello&quot;) HelloService helloService2; HelloService helloService3; HelloService helloService4; public Test() &#123; ARouter.getInstance().inject(this); &#125; public void testService() &#123; // 1. (推荐)使用依赖注入的方式发现服务,通过注解标注字段,即可使用，无需主动获取 // Autowired注解中标注name之后，将会使用byName的方式注入对应的字段，不设置name属性，会默认使用byType的方式发现服务(当同一接口有多个实现的时候，必须使用byName的方式发现服务) helloService.sayHello(&quot;Vergil&quot;); helloService2.sayHello(&quot;Vergil&quot;); // 2. 使用依赖查找的方式发现服务，主动去发现服务并使用，下面两种方式分别是byName和byType helloService3 = ARouter.getInstance().navigation(HelloService.class); helloService4 = (HelloService) ARouter.getInstance().build(&quot;/service/hello&quot;).navigation(); helloService3.sayHello(&quot;Vergil&quot;); helloService4.sayHello(&quot;Vergil&quot;); &#125;&#125;事件通知：第三个场景可使用Android的本地广播或者EventBus：https://github.com/greenrobot/EventBus定义事件：1public static class MessageEvent &#123; /* Additional fields if needed */ &#125;事件响应：12@Subscribe(threadMode = ThreadMode.MAIN) public void onMessageEvent(MessageEvent event) &#123;/* Do something */&#125;;注册EventBus：1234567891011@Overridepublic void onStart() &#123; super.onStart(); EventBus.getDefault().register(this);&#125;@Overridepublic void onStop() &#123; super.onStop(); EventBus.getDefault().unregister(this);&#125;发送事件：1EventBus.getDefault().post(new MessageEvent());]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理和注解处理接口Token问题]]></title>
    <url>%2Farchives%2Fcdd0265b.html</url>
    <content type="text"><![CDATA[背景目前在做SDK时，网络层使用的框架是OkHttp + Retrofit，需要对外提供API方式的网络接口调用。一般来说，后台都会有接口校验设计，需要在请求头包含部分加密参数进行验证。我们的项目也是这样处理，外放的接口需要先调用登录接口获取Token，根据Token在请求头进行组合形成鉴权，才能成功通过后台的校验进行使用。这时候想，如果每个接口都需要提前先获取Token，工作量非常大，于是想到了类似Java的AOP的面向切面处理方式，使用动态代理灵活在接口方法前插入获取Token逻辑。而部分接口例如，获取验证码、登录相关的，并不需要Token，因此再自定义一个注解用于区别。动态代理要理解动态代理首先要理解代理，代理：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。代理有什么用呢？举个例子，上大学偶尔舍友会不想上他自己的课，于是让我去代签名，此时我就成为了这个舍友的代理，替他去上课。一般来说，我们使用聚合方式让代理类持有一个被代理类对象，即可实现代理，而此种方式一般称为静态代理。在项目中我们有一个Repository实现了具体的网络接口请求，里面有许多接口方法，如下所示：123456public class Repository implements IRepository &#123; void method1() &#123;...&#125; void method2() &#123;...&#125; void method3() &#123;...&#125; ... &#125;目前我们想要有一个Repository的Proxy类，在每个接口前加入获取Token的逻辑，如果用静态代理来做，如下：12345678910111213141516171819public class RepositoryProxy implements IRepository &#123; IRepository repository; void method1() &#123; getToken(); repository.method1(); &#125; void method2() &#123; getToken(); repository.method2(); &#125; void method3() &#123; getToken(); repository.method3(); &#125; ... void getToken() &#123;...&#125;&#125;可以看到每个接口前都需要调用getToken，同样的逻辑需要反复实现，虽然效果达到了，但是由此写了很多重复的代码，因此静态代理也不适用于我们的需求。于是使用动态代理来实现，这样就达到了预期的效果，如下：1234567891011121314public class RepositoryInvocationHandler implements InvocationHandler &#123; IRepository repository; @Override public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable &#123; if(如果需要Token) &#123; getToken(); &#125; return method.invoke(repository, args); &#125; void getToken() &#123;...&#125;&#125;具体是实现InvocationHandler接口，覆写invoke方法，method.invoke(repository, args)即等价于调用IRepository的网络请求接口，在此方法前可以插入自定义逻辑。在原本需要调用Repository的地方生成动态代理方式，如下：123Repository repository = new Repository();RepositoryInvocationHandler repositoryInvocationHandler = new RepositoryInvocationHandler(repository);proxy = (IRepository) (Proxy.newProxyInstance(IRepository.class.getClassLoader(), new Class[]&#123;IRepository.class&#125;, repositoryInvocationHandler));注解注解（也被成为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。 ———摘自《Thinking in Java》简单来说注解的作用就是将我们的需要的数据储存起来，在以后的某一个时刻（可能是编译时，也可能是运行时）去调用它。在我们的项目中，针对部分接口不需要Token的，处理逻辑不同，于是通过自定义注解实现，如下：1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface NeedToken &#123;&#125;在Repository中，对需要获取Token的方法前加@NeedToken即可。最后修改InvocationHandler的逻辑，如下：1234567891011121314151617public class RepositoryInvocationHandler implements InvocationHandler &#123; IRepository repository; @Override public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable &#123; // 如果带NeedToken有注解，先判断是否获取了Token，否则需要获取，再调用API方法 NeedToken isNeedToken = method.getAnnotation(NeedToken.class); if(isNeedToken != null) &#123; getToken(); &#125; // 否则直接调用方法即可 return method.invoke(repository, args); &#125; void getToken() &#123;...&#125;&#125;另外，由于getToken一般也为一个接口方法，需要异步回调获取Token，需注意RepositoryInvocationHandler类不能写成单例，应该每个接口方法对应一个proxy，对应一个获取Token回调，否则会造成冲突。Done.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SlidingCheckLayout滑动选择布局实现]]></title>
    <url>%2Farchives%2F2720d64c.html</url>
    <content type="text"><![CDATA[背景项目需求，要求在选择本地图片时，可对图片进行滑动选择。类似小米图库或者图库，现在很多手机系统内置图库都自带了这个功能。最后经过调研，使用自定义View解决。SlidingCheckLayout滑动选择布局，用于嵌套RecyclerView实现滑动选择功能。效果如图所示：最后将代码整理了一下，并上传到Jitpack。源码https://github.com/huangyu/SlidingCheckLayout引用方式在根目录：123456allprojects &#123; repositories &#123; ... maven &#123; url &apos;https://jitpack.io&apos; &#125; &#125;&#125;添加依赖：1234dependencies &#123; ... implementation &apos;com.github.huangyu0:SlidingCheckLayout:x.x.x&apos;&#125;使用方法在layout的xml中，在RecyclerView外层嵌套SlidingCheckLayout作为唯一子节点。在App中实现SlidingCheckLayout.OnSlidingCheckListener接口即可，具体可参考Demo工程。原理通过onInterceptTouchEvent方法拦截滑动请求，找到起始点坐标。12345678// 计算起始点坐标View child = targetRlv.findChildViewUnder(ev.getX(), ev.getY());if (child != null) &#123; int position = targetRlv.getChildAdapterPosition(child); if (position != RecyclerView.*NO_POSITION*&amp;&amp; startPos != position) &#123; startPos = position; &#125;&#125;RecycleView的findChildViewUnder()方法，可以十分方便返回指定位置的childView。判断是否处于滑动状态，xTouchSlop和yTouchSlop为横向和纵向两个阈值。12345float xDiff = Math.*abs*(ev.getX() - startX);float yDiff = Math.*abs*(ev.getY() - startY);if (yDiff &lt; yTouchSlop &amp;&amp; xDiff &gt; xTouchSlop) &#123; isSliding = true;&#125;为了和RecycleView的Item点击事件不冲突，通过自定义一个判断标记isSliding，返回是否拦截滑动请求，即是否进行了滑动选择。通过onTouchEvent处理具体的拦截逻辑。12345678910111213141516171819202122@Overridepublic boolean onTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.*ACTION_DOWN*: break; case MotionEvent.*ACTION_MOVE*: if (!inTopSpot &amp;&amp; !inBottomSpot) &#123; // 处理滑动事件 updateSelectedRange(targetRlv, ev); &#125; // 在顶部或者底部触发自动滑动 processAutoScroll(ev); break; case MotionEvent.*ACTION_UP*: resetParams(); stopAutoScroll(); performClick(); return false; &#125; return isSliding;&#125;既然是滑动，处理事件肯定是在ACTION_MOVE里。这里的inTopSpot和inBottomSpot两个标记用于计算是否滑动到顶部或者底部，用于滑动到顶部或者底部时，使用Scroller进行自动滚动。具体实现在processAutoScroll方法。updateSelectedRange则处理滑动选择。12345678910private void updateSelectedRange(RecyclerView rv, float x, float y) &#123; View child = rv.findChildViewUnder(x, y); if (child != null) &#123; int position = rv.getChildAdapterPosition(child); if (position != RecyclerView.*NO_POSITION*&amp;&amp; endPos != position) &#123; endPos = position; notifySelectRangeChange(); &#125; &#125;&#125;这里同样用findChildViewUnder方法记录结束标志，现在获取到了起始点和结束点。12345678910111213141516171819202122232425262728293031private void notifySelectRangeChange() &#123; if (onSlidingCheckListener == null) &#123; return; &#125; if (startPos == RecyclerView.*NO_POSITION*|| endPos == RecyclerView.*NO_POSITION*) &#123; return; &#125; int newStart, newEnd; newStart = Math.*min*(startPos, endPos); newEnd = Math.*max*(startPos, endPos); if (lastStartPos == RecyclerView.*NO_POSITION*|| lastEndPos == RecyclerView.*NO_POSITION*) &#123; onSlidingCheckListener.onSlidingCheckPos(newStart, newEnd); &#125; else &#123; if (newStart &gt; lastStartPos) &#123; onSlidingCheckListener.onSlidingCheckPos(lastStartPos, newStart - 1); &#125; else if (newStart &lt; lastStartPos) &#123; onSlidingCheckListener.onSlidingCheckPos(newStart, lastStartPos - 1); &#125; if (newEnd &gt; lastEndPos) &#123; onSlidingCheckListener.onSlidingCheckPos(lastEndPos + 1, newEnd); &#125; else if (newEnd &lt; lastEndPos) &#123; onSlidingCheckListener.onSlidingCheckPos(newEnd + 1, lastEndPos); &#125; &#125; lastStartPos = newStart; lastEndPos = newEnd;&#125;notifySelectRangeChange为核心处理逻辑，通过当前滑动的起始点和终点计算中间滑动的范围并回调给调用方。这里自定义了一个回调接口类：123public interface OnSlidingCheckListener &#123; void onSlidingCheckPos(int startPos, int endPos);&#125;最后外部使用回调对起始点至终点部分进行选择处理。123456789101112131415scl.setOnSlidingCheckListener(new SlidingCheckLayout.OnSlidingCheckListener() &#123; @Override public void onSlidingCheckPos(int startPos, int endPos) &#123; RecyclerView recyclerView = (RecyclerView) scl.getChildAt(0); for (int I = startPos; I &lt;= endPos; I++) &#123; View current = recyclerView.getLayoutManager().findViewByPosition(i); if (current != null) &#123; View currentLayout = current.findViewById(R.id.*rl_root*); if (currentLayout != null) &#123; currentLayout.performClick(); &#125; &#125; &#125; &#125;&#125;);Done.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法汇总]]></title>
    <url>%2Farchives%2F3c50d03d.html</url>
    <content type="text"><![CDATA[Markdown语法汇总标题使用#，可表示1-6级标题。一级标题二级标题三级标题四级标题五级标题六级标题无序列表使用·、+、或-标记无序列表。注意：标记后面最少有一个_空格_或制表符。若不在引用区块中，必须和前方段落之间存在空行。无序列表1无序列表2无序列表3有序列表有序列表的标记方式是将上述的符号换成数字,并辅以.。有序列表1有序列表2有序列表3强调在强调内容两侧分别加上*或者_。斜体_斜体加粗加粗段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用。引用嵌套引用代码代码区块的建立是在每行加上4个空格或者一个制表符。void main() { printf(&quot;Hello, Markdown.&quot;); } 或者使用上下三个`包裹。1234void main()&#123; printf(&quot;Hello, Markdown.&quot;);&#125;分割线分割线最常使用就是三个或以上*，还可以使用-和_。链接，[]内为描述信息，()为链接地址。huangyu的随记随想图片添加图片的形式和链接相似，只需在链接的基础上前方加一个!。转义\相当于反转义作用。使符号成为普通符号。标记`符号起到标记作用。标记表格在 Markdown 中，可以制作表格。1234First Header | Second Header | Third Header------------ | ------------- | ------------Content Cell | Content Cell | Content CellContent Cell | Content Cell | Content CellFirst HeaderSecond HeaderThird HeaderContent CellContent CellContent CellContent CellContent CellContent Cell或者也可以让表格两边内容对齐，中间内容居中。1234First Header | Second Header | Third Header:----------- | :-----------: | -----------:Left | Center | RightLeft | Center | RightFirst HeaderSecond HeaderThird HeaderLeftCenterRightLeftCenterRight]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
